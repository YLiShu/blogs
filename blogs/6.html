<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>现代软件工程 | 黎子🌰码境</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="shortcut icon" href="favicon.ico">
    <meta name="description" content="在代码的迷宫中穿梭，书写着改变生活的数字篇章">
    
    <link rel="preload" href="/blogs/assets/css/0.styles.d9a4f19e.css" as="style"><link rel="preload" href="/blogs/assets/js/app.b10d3b76.js" as="script"><link rel="preload" href="/blogs/assets/js/7.51cf2bb3.js" as="script"><link rel="preload" href="/blogs/assets/js/2.90913472.js" as="script"><link rel="preload" href="/blogs/assets/js/1.c35ebe2c.js" as="script"><link rel="preload" href="/blogs/assets/js/67.fecbf0ba.js" as="script"><link rel="prefetch" href="/blogs/assets/js/10.51f51c0e.js"><link rel="prefetch" href="/blogs/assets/js/11.f1c4e2ce.js"><link rel="prefetch" href="/blogs/assets/js/14.90b34deb.js"><link rel="prefetch" href="/blogs/assets/js/15.cd05d3f7.js"><link rel="prefetch" href="/blogs/assets/js/16.0ca60d78.js"><link rel="prefetch" href="/blogs/assets/js/17.26773bd0.js"><link rel="prefetch" href="/blogs/assets/js/18.21df733a.js"><link rel="prefetch" href="/blogs/assets/js/19.eed3c532.js"><link rel="prefetch" href="/blogs/assets/js/20.4c76e8be.js"><link rel="prefetch" href="/blogs/assets/js/21.f18babb4.js"><link rel="prefetch" href="/blogs/assets/js/22.249f648e.js"><link rel="prefetch" href="/blogs/assets/js/23.cb41f22a.js"><link rel="prefetch" href="/blogs/assets/js/24.c95ba296.js"><link rel="prefetch" href="/blogs/assets/js/25.4a450405.js"><link rel="prefetch" href="/blogs/assets/js/26.b1851237.js"><link rel="prefetch" href="/blogs/assets/js/27.ab146b7f.js"><link rel="prefetch" href="/blogs/assets/js/28.83af5ecf.js"><link rel="prefetch" href="/blogs/assets/js/29.17c1b3c2.js"><link rel="prefetch" href="/blogs/assets/js/3.8ff04919.js"><link rel="prefetch" href="/blogs/assets/js/30.5a702d15.js"><link rel="prefetch" href="/blogs/assets/js/31.9b363f9c.js"><link rel="prefetch" href="/blogs/assets/js/32.df071e6e.js"><link rel="prefetch" href="/blogs/assets/js/33.83f13db0.js"><link rel="prefetch" href="/blogs/assets/js/34.a5e21847.js"><link rel="prefetch" href="/blogs/assets/js/35.caa9411a.js"><link rel="prefetch" href="/blogs/assets/js/36.0997f85f.js"><link rel="prefetch" href="/blogs/assets/js/37.41a69cda.js"><link rel="prefetch" href="/blogs/assets/js/38.11c97fc9.js"><link rel="prefetch" href="/blogs/assets/js/39.c7a91778.js"><link rel="prefetch" href="/blogs/assets/js/4.7ab60d34.js"><link rel="prefetch" href="/blogs/assets/js/40.788bd3bb.js"><link rel="prefetch" href="/blogs/assets/js/41.bfd620d2.js"><link rel="prefetch" href="/blogs/assets/js/42.a93d1dad.js"><link rel="prefetch" href="/blogs/assets/js/43.36e369c4.js"><link rel="prefetch" href="/blogs/assets/js/44.a8c7c1be.js"><link rel="prefetch" href="/blogs/assets/js/45.be0bd724.js"><link rel="prefetch" href="/blogs/assets/js/46.0eead14d.js"><link rel="prefetch" href="/blogs/assets/js/47.9c0b8ec3.js"><link rel="prefetch" href="/blogs/assets/js/48.fedde897.js"><link rel="prefetch" href="/blogs/assets/js/49.658232de.js"><link rel="prefetch" href="/blogs/assets/js/5.07521870.js"><link rel="prefetch" href="/blogs/assets/js/50.e75baace.js"><link rel="prefetch" href="/blogs/assets/js/51.39f09a2a.js"><link rel="prefetch" href="/blogs/assets/js/52.86d8775b.js"><link rel="prefetch" href="/blogs/assets/js/53.2bcea0af.js"><link rel="prefetch" href="/blogs/assets/js/54.80cfc079.js"><link rel="prefetch" href="/blogs/assets/js/55.575fad98.js"><link rel="prefetch" href="/blogs/assets/js/56.a9ac12aa.js"><link rel="prefetch" href="/blogs/assets/js/57.bc25fe73.js"><link rel="prefetch" href="/blogs/assets/js/58.a1f3dfda.js"><link rel="prefetch" href="/blogs/assets/js/59.acfc0f60.js"><link rel="prefetch" href="/blogs/assets/js/6.7070ea7f.js"><link rel="prefetch" href="/blogs/assets/js/60.cfc92fb7.js"><link rel="prefetch" href="/blogs/assets/js/61.566a8f66.js"><link rel="prefetch" href="/blogs/assets/js/62.1c3ab2d6.js"><link rel="prefetch" href="/blogs/assets/js/63.f1df4d25.js"><link rel="prefetch" href="/blogs/assets/js/64.349b7d3b.js"><link rel="prefetch" href="/blogs/assets/js/65.3e277b74.js"><link rel="prefetch" href="/blogs/assets/js/66.f985ae29.js"><link rel="prefetch" href="/blogs/assets/js/68.1f08c812.js"><link rel="prefetch" href="/blogs/assets/js/69.55f47746.js"><link rel="prefetch" href="/blogs/assets/js/70.66e490da.js"><link rel="prefetch" href="/blogs/assets/js/8.8dfb1e90.js"><link rel="prefetch" href="/blogs/assets/js/9.18b271e2.js"><link rel="prefetch" href="/blogs/assets/js/vendors~docsearch.814a0df0.js">
    <link rel="stylesheet" href="/blogs/assets/css/0.styles.d9a4f19e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>黎子🌰码境</h3> <p class="description" data-v-59e6cb88>在代码的迷宫中穿梭，书写着改变生活的数字篇章</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>黎子</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blogs/" class="home-link router-link-active"><img src="/blogs/avatar.jpg" alt="黎子🌰码境" class="logo"> <span class="site-name">黎子🌰码境</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/计算机网络/" class="nav-link"><i class="undefined"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/学校课程/" class="nav-link"><i class="undefined"></i>
  学校课程
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      黎子🌰Code
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3206591176245848" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/YLiShu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/blogs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/blogs/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    黎子
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>32</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>18</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/计算机网络/" class="nav-link"><i class="undefined"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/学校课程/" class="nav-link"><i class="undefined"></i>
  学校课程
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      黎子🌰Code
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3206591176245848" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/YLiShu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/blogs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>现代软件工程</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>黎子</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">现代软件工程</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>黎子</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/11/13</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>学校课程</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="软件及软件工程"><a href="#软件及软件工程" class="header-anchor">#</a> 软件及软件工程</h1> <h2 id="什么是软件"><a href="#什么是软件" class="header-anchor">#</a> 什么是软件</h2> <p>计算机软件指计算机系统中的程序、数据及其相关文档</p> <ul><li>程序：按照指定顺序组织的计算机数据和指令的集合</li> <li>数据：使程序能正常执行的数据结构</li> <li>文档：为了便于理解程序所需的与开发、维护和使用相关的资料</li></ul> <h2 id="什么是软件危机"><a href="#什么是软件危机" class="header-anchor">#</a> 什么是软件危机</h2> <p>软件危机指计算机软件的开发和维护过程所遇到的一系列严重问题</p> <h2 id="什么是软件工程"><a href="#什么是软件工程" class="header-anchor">#</a> 什么是软件工程</h2> <p>软件工程的定义：</p> <ol><li>把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件</li> <li>研究 (1) 中提到的途径</li></ol> <h2 id="软件工程的内容"><a href="#软件工程的内容" class="header-anchor">#</a> 软件工程的内容</h2> <ul><li>软件工程是一种层次化技术。任何工程方法必须构建在质量承诺的基础上</li> <li>软件工程的基础是过程。软件过程将各个技术层次结合在一起，使得合理、即时地开发计算机软件成为可能</li> <li>软件工程方法为构建软件提供技术上的解决方法</li> <li>软件工程工具为过程和方法提供自动化或半自动化的支持</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685492402949.png" alt="1685492402949.png"></p> <h2 id="软件工具"><a href="#软件工具" class="header-anchor">#</a> 软件工具</h2> <p>软件工具是指能支持软件生存周期中某一阶段（如系统定义、需求分析、设计、编码、测试或维护）的需要而使用的软件工具
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685492732435.png" alt="1685492732435.png"></p> <h2 id="软件工程方法"><a href="#软件工程方法" class="header-anchor">#</a> 软件工程方法</h2> <ol><li>传统方法学（主要强调程序的易读性）
<ul><li>传统方法学也称为生命周期方法学或结构化方法学。采使用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务，并用适当的软件工具或软件工程环境来支持结构化技术的运用</li></ul></li> <li>面向对象方法学
<ul><li>与传统方法相反，面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密结合起来的方法</li></ul></li> <li>形式化方法学
<ul><li>是一种基于形式化数学变换的软件开发方法</li> <li>建立在严格数学基础上的软件开发方法。形式化方法模型的主要活动是生成形式化的数学规格说明。形式化方法使软件开发人员可以应用严格的数学符号来说明、开发和验证基于计算机的系统</li></ul></li></ol> <h2 id="框架活动"><a href="#框架活动" class="header-anchor">#</a> 框架活动</h2> <ul><li>沟通——需求获取</li> <li>策划——项目计划</li> <li>建模
<ul><li>需求模型</li> <li>设计模型</li></ul></li> <li>构建
<ul><li>编码</li> <li>测试</li></ul></li> <li>部署</li></ul> <h2 id="软件生命周期"><a href="#软件生命周期" class="header-anchor">#</a> 软件生命周期</h2> <ul><li>又称为软件生存周期</li> <li>是软件从产生直到报废的整个时期</li></ul> <h3 id="软件工程三要素"><a href="#软件工程三要素" class="header-anchor">#</a> 软件工程三要素</h3> <ul><li>过程</li> <li>方法</li> <li>工具</li></ul> <h3 id="软件生命周期模型"><a href="#软件生命周期模型" class="header-anchor">#</a> 软件生命周期模型</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685493991471.png" alt="1685493991471.png"></p> <h2 id="作业1"><a href="#作业1" class="header-anchor">#</a> 作业1</h2> <blockquote><ol><li>在瀑布模型中，将软件划分为若干个时期，软件项目可行性研究一般归属于（计划时期）</li> <li>软件工程的基本要素包括方法、工具和（过程）</li> <li>软件的组成包括程序、数据和文档</li> <li>UML是软件开发中的一个重要工具，它主要应用于哪种软件开发方法（基于对象的面向对象的方法）</li> <li>结构化程序设计主要强调的是（程序的易读性）</li> <li>软件生存周期包括可行性分析、需求分析、概要设计、详细设计、编码、（测试）、维护等活动</li></ol></blockquote> <h1 id="软件过程及过程模型"><a href="#软件过程及过程模型" class="header-anchor">#</a> 软件过程及过程模型</h1> <h2 id="什么是软件过程"><a href="#什么是软件过程" class="header-anchor">#</a> 什么是软件过程</h2> <p>一个为创建高质量软件所需要完成的活动、动作和任务的框架</p> <h3 id="通用活动"><a href="#通用活动" class="header-anchor">#</a> 通用活动</h3> <ul><li>沟通</li> <li>策划</li> <li>建模
<ul><li>创建模型</li> <li>设计</li></ul></li> <li>构建
<ul><li>编码</li> <li>测试</li></ul></li> <li>部署</li></ul> <h3 id="软件过程模型"><a href="#软件过程模型" class="header-anchor">#</a> 软件过程模型</h3> <ul><li>也称软件开发模型或软件生存周期模型，是软件生存周期中一系列有序的软件开发活动的流程，是软件开发全部活动的结构框架</li> <li>对一个软件的开发无论其大小，都需要选择一个合适的软件过程模型，主要根据软件的类型、规模，开发方法、开发环境等多种因素来确定</li></ul> <h3 id="通用过程模型"><a href="#通用过程模型" class="header-anchor">#</a> 通用过程模型</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685496644711.png" alt="1685496644711.png"></p> <h3 id="过程流"><a href="#过程流" class="header-anchor">#</a> 过程流</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685496681235.png" alt="1685496681235.png"></p> <h3 id="过程模型"><a href="#过程模型" class="header-anchor">#</a> 过程模型</h3> <ul><li>写了再改模型</li> <li>瀑布模型</li> <li>增量过程模型</li> <li>演化过程模型
<ul><li>原型开发模型</li> <li>螺旋模型</li></ul></li> <li>并发模型</li> <li>基于构件的开发</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685930603268.png" alt="1685930603268.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685931115493.png" alt="1685931115493.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685931181121.png" alt="1685931181121.png"></p> <h4 id="瀑布模型的变体-v模型"><a href="#瀑布模型的变体-v模型" class="header-anchor">#</a> 瀑布模型的变体——V模型</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685931759766.png" alt="1685931759766.png"></p> <h5 id="瀑布模型的特点"><a href="#瀑布模型的特点" class="header-anchor">#</a> 瀑布模型的特点</h5> <ul><li>阶段间具有顺序性和依赖性</li> <li>推迟实现的观点</li> <li>质量保证的观点</li></ul> <h5 id="瀑布模型的优点"><a href="#瀑布模型的优点" class="header-anchor">#</a> 瀑布模型的优点</h5> <ul><li>可强迫开发人员采用规范的方法（例如，结构化技术）。</li> <li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证</li> <li>严格地规定了每个阶段必须提交的文档</li></ul> <h5 id="瀑布模型的问题"><a href="#瀑布模型的问题" class="header-anchor">#</a> 瀑布模型的问题</h5> <ul><li>难以应对需求变化：客户难以准确表达需求，软件团队很难准确理解需求</li> <li>过于理想：实际项目很少按照该模型给出的顺序进行</li> <li>风险太大：用户必须有耐心，等到系统开发完成才能见到软件</li> <li>阻塞状态：开发者常常被不必要地耽搁</li></ul> <h5 id="瀑布模型的适用场景"><a href="#瀑布模型的适用场景" class="header-anchor">#</a> 瀑布模型的适用场景</h5> <ul><li>需求相当稳定，客户需求被全面的了解风险管理</li> <li>开发团队对于应用领域非常熟悉</li> <li>外部环境的不可控因素很少</li> <li>小型清晰的项目</li></ul> <h4 id="原型开发模型-快速模型"><a href="#原型开发模型-快速模型" class="header-anchor">#</a> 原型开发模型（快速模型）</h4> <ul><li><p>原型开发模型的产生</p> <ul><li>瀑布模型将软件生命周期划分为独立串行的几个阶段，前一个阶段没有完成便无法开始下一阶段的工作</li> <li>而完整而准确的需求规格说明是很难得到的，因为：
<ul><li>开发早期用户往往对系统只有一个模糊的想法，很难准确表达对系统的全面要求</li> <li>随着开发工作推进，用户可能产生新需求</li> <li>开发者可能在设计与实现中遇到没有预料到的困难，需要改变需求来解脱困境</li></ul></li></ul></li> <li><p>原型是预期系统的一个可执行版本，反映了系统性质（如功能、计算结果等）的一个选定的子集</p></li> <li><p>一个原型不必满足目标软件的所有约束，其目的是能快速、低成本地构建原型</p></li> <li><p>被开发的原型应交付给客户试用，并收集客户的反馈意见，这些反馈意见可在下一轮迭代中对原型进行改进。在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发</p></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685933342496.png" alt="1685933342496.png"></p> <h5 id="原型开发的优点"><a href="#原型开发的优点" class="header-anchor">#</a> 原型开发的优点</h5> <ul><li>快速开发出可以演示的系统，方便了客户沟通</li> <li>采用迭代技术能够使开发者逐步弄清客户的需求</li></ul> <h5 id="原型的使用策略"><a href="#原型的使用策略" class="header-anchor">#</a> 原型的使用策略</h5> <ul><li>废弃策略
<ul><li>主要用于探索型和实验型原型的开发。这些原型关注于目标系统的某些特性，而不是全部特性，开发这些原型时通常不考虑于探索或实验目的无关的功能、质量、结构等因素，这种原型通常被丢弃，然后根据探索或实验的结果用良好的结构和设计思想重新设计目标系统</li></ul></li> <li>追加策略
<ul><li>主要用于演化型原型的开发。这种原型通常是实现了目标系统中已明确定义的特性的一个子集，通过对它的不断修改和扩充，逐步追加新的需求，最后使其演化成最终的目标系统</li></ul></li></ul> <h5 id="原型模型-适用情况"><a href="#原型模型-适用情况" class="header-anchor">#</a> 原型模型——适用情况</h5> <ul><li>用户定义了一组一般性目标，但不能标识出详细的输入、处理及输出需求</li> <li>开发者可能不能确定算法的有效性、操作系统的适应性或人机交互的形式</li></ul> <h4 id="增量模型"><a href="#增量模型" class="header-anchor">#</a> 增量模型</h4> <ul><li>增量模型以迭代的方式运用瀑布模型</li> <li>随着时间的推移，发布一系列称为增量的版本，随着每个版本的交付，逐步为用户提供更多的功能</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685933997551.png" alt="1685933997551.png"></p> <h5 id="增量模型的使用方法"><a href="#增量模型的使用方法" class="header-anchor">#</a> 增量模型的使用方法</h5> <ul><li>软件被作为一系列的增量来进行开发，每一个增量都提交一个可操作的产品，可供用户评估</li> <li>第一个增量往往是核心产品：满足了基本的需求，但是缺少附加的特性</li> <li>客户使用上一个增量的提交物并进行评价，制定下一个增量计划，说明需要增加的特性和功能</li> <li>重复上述过程，直到最终产品产生为止</li></ul> <h5 id="增量模型的优点"><a href="#增量模型的优点" class="header-anchor">#</a> 增量模型的优点</h5> <ul><li>提高对用户需求的响应：用户看到可操作的早期版本后会提出一些建议和需求，可以在后续增量中调整。</li> <li>人员分配灵活：如果找不到足够的开发人员，可采用增量模型，早期的增量由少量人员实现，如果客户反响较好，则在下一个增量中投入更多的人力</li> <li>可规避技术风险：不确定的功能放在后面开发</li></ul> <h5 id="增量模型存在的问题"><a href="#增量模型存在的问题" class="header-anchor">#</a> 增量模型存在的问题</h5> <ul><li>每个附加的增量并入现有的软件时，必须不破坏原来已构造好的东西</li> <li>加入新增量时应简单、方便——软件的体系结构应当是开放的</li> <li>仍然无法处理需求发生变更的情况</li> <li>管理人员须有足够的技术能力来协调好各增量之间的关系</li> <li>难以确定所有版本共需的公用模块</li></ul> <h4 id="螺旋模型"><a href="#螺旋模型" class="header-anchor">#</a> 螺旋模型</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685950808617.png" alt="1685950808617.png"></p> <h5 id="螺旋模型示意图"><a href="#螺旋模型示意图" class="header-anchor">#</a> 螺旋模型示意图</h5> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685950947630.png" alt="1685950947630.png"></p> <h5 id="螺旋模型的优点"><a href="#螺旋模型的优点" class="header-anchor">#</a> 螺旋模型的优点</h5> <ul><li>结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种风险驱动型的过程模型</li> <li>采用循环的方式逐步加深系统定义和实现的深度，同时更好地理解、应对和降低风险</li> <li>确定一系列里程碑，确保各方都得到可行的系统解决方案</li> <li>始终保持可操作性，直到软件生命周期的结束</li> <li>风险驱动</li></ul> <h5 id="螺旋模型存在的问题"><a href="#螺旋模型存在的问题" class="header-anchor">#</a> 螺旋模型存在的问题</h5> <ul><li>螺旋模型依赖大量的风险评估专家来保证成功。如果有较大的风险没有被发现和管理，肯定会发生问题。</li> <li>软件开发人员应该擅长寻找可能的风险，准确的分析风险，否则将会带来更大的风险。</li></ul> <blockquote><p>问题：假设要求你开发ー个软件，该软件的功能是把读入的浮点数开平方，所得到的结果应该精确到小数点后4位。你打算采用哪种软件过程模型？为什么？</p> <p>答：瀑布模型是一种线性的开发过程模型，它的每个阶段都必须按顺序完成，每个阶段的输出成果物都需要经过严格的评审和批准才能进入下一个阶段。这种模型适用于需求明确、变化少、开发过程易于管理的项目。</p> <p>对于这个软件开发项目，需求明确，变化很少，因为只有一个简单的功能需求，即对输入浮点数进行平方根运算并返回精确到小数点后4位的结果。因此，我认为瀑布模型是一个合适的选择。</p> <p>瀑布模型的另一个优点是它容易管理和控制，因为每个阶段都有明确的目标和成果物，以及严格的评审和批准过程。这可以帮助确保项目按时交付，并且符合预算和质量标准。</p> <p>因此，基于以上原因，我会选择瀑布模型来开发这个软件。</p></blockquote> <blockquote><p>问题：假设你被任命为一家软件公司的项目负责人，你的工作是管理该公司已被广泛应用的字处理软件的新版本开发。由于市场竞争激烈，公司规定了严格的完成期限并且已对外公布。你打算采用哪种软件过程模型？为什么？</p> <p>答：对这个项目的一个重要要求是，严格按照已对外公布了的日期完成产品开发工作，因此，选择生命周期模型时、应该着重考虑哪种模型有助于加快产品开发的进度。使用增量模型开发软件时可以并行完成开发工作，因此能够加快开发进度。</p> <p>这个项目是开发该公司已被广泛应用的字处理软件的新版本，从上述事实至少可以得出3点结论：</p> <p>第一，旧版本相当于一个原型，通过收集用户对旧版本的反映，较容易确定对新版本的需求，没必要再专门建立一个原型系统来分析用户的需求</p> <p>第二，该公司的软件工程师对字处理软件很熟悉，有开发字处理软件的丰富经验，具有采用增量模型开发新版字处理软件所需要的技术水平</p> <p>第三，该软件受到广大用户的喜爱，今后很可能还要开发更新的版本，因此，应该把该软件的体系结构设计成开放式的，以利于今后的改进和扩充。</p></blockquote> <blockquote><p>问题：假设你负责开发一个位于火车站的交互式火车车次查询系统。你打算采用哪种软件过程模型？为什么？</p> <p>答：选择原型模型，原型模型是一种快速开发软件的方法，它通过创建一个初步版本的软件系统来帮助理解用户需求和系统功能，以便在后续的开发过程中进行迭代和改进。在这种情况下，原型模型可以帮助团队更好地理解用户的需求和期望，以便开发出满足用户需求的交互式火车车次查询系统。</p> <p>原型模型与其他软件过程模型的不同之处在于，它强调通过快速迭代和反馈来开发系统，而不是一开始就完全理解和规划系统的所有方面。这种方法可以减少开发过程中的错误和风险，并提高开发效率和用户满意度。</p> <p>对于交互式火车车次查询系统，原型模型尤其适用，因为该系统需要与用户进行交互，并提高准确和实时的信息。通过使用原型模型，团队可以更好地理解用户需求和行为模式，并针对性地改进系统的交互和功能，以提高用户的使用体验和满意度。</p></blockquote> <blockquote><p>问题：开发团队了解待开发软件的相关领域知识，尽管此系统庞大，但其较已经开发的系统差异并不大。你打算采用哪种软件过程模型？为什么？</p> <p>答：选择瀑布模型，从描述中可以看出，开发团队已经了解待开发软件的相关领域知识，而且该系统与已经开发的系统差异并不大，因此系统的需求比较稳定，适合采用瀑布模型进行开发。在瀑布模型中，需求分析是非常关键的一个阶段，因为后续的设计、编码和测试都依赖于需求分析的结果。如果需求分析不充分或者不准确，就会导致后续阶段的问题和变更，增加项目开发的风险和成本。</p></blockquote> <h4 id="专用过程模型"><a href="#专用过程模型" class="header-anchor">#</a> 专用过程模型</h4> <ul><li>基于构件的开发 —— 能够使软件复用</li> <li>形式化方法模型 —— 注重需求的数学规格说明</li> <li>面向方面的软件开发 —— 为定义、说明、设计和构建方面提高过程和方法</li> <li>统一过程 —— 一种”用例驱动、以构架为中心的迭代和增量“，软件过程和统一建模（UML）紧密结合</li></ul> <h5 id="基于构件的开发"><a href="#基于构件的开发" class="header-anchor">#</a> 基于构件的开发</h5> <ul><li>是在一定构件模型的支持下，复用构件库中的一个或多个软件构件，通过组合手段（集成）高效率、高质量地构造应用软件系统的过程</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1685969118129.png" alt="1685969118129.png"></p> <p>优点：</p> <ul><li>充分利用软件复用，提高了软件开发的效率</li> <li>允许多个项目同时开发，降低了费用，提高了可维护性，可实现分布提交软件产品</li></ul> <p>缺点：</p> <ul><li>缺乏通用的构件组件结构标准，风险较大</li> <li>构件可重用性和系统高效性之间不易协调</li> <li>由于过分依赖于构件，构件质量影响着最终产品的质量</li></ul> <h5 id="形式化方法模型"><a href="#形式化方法模型" class="header-anchor">#</a> 形式化方法模型</h5> <ul><li>从广义上讲，形式化方法是指借助数学的方法来解决软件工程领域的问题，主要包括建立精确的数学模型以及对模型的分析活动</li> <li>狭义的讲，形式化方法是运用形式化语言，进行形式化的规格描述、模型推理和验证的方法</li> <li>形式化方法原则上就是用数学与逻辑的方法描述和验证软件</li> <li>可以实现从描述到实现的自动转换</li></ul> <p>优点：</p> <ul><li>能够开发出无缺陷的软件</li></ul> <p>缺点：</p> <ul><li>成本高、耗时</li> <li>对开发人员的技术水平要求高</li></ul> <blockquote><p>问题1：开发质量“足够好”的软件，有什么优点和缺点？</p> <p>答：高质量意味着工作量增加、成本增加、开发时间延长</p></blockquote> <blockquote><p>问题2：我们可以证明一个软件构件甚至整个程序的正确性（形式化方法），可是为什么并不是每个人都这样做？</p> <p>答：形式化方法开发非常耗时，成本高、对开发人员的技术水平要求高</p></blockquote> <h2 id="作业2"><a href="#作业2" class="header-anchor">#</a> 作业2</h2> <blockquote><ol><li>下列关于敏捷方法的叙述中，<strong>错误</strong>的是（敏捷方法尤其适用于开发团队比较庞大的项目），<strong>正确</strong>的是（与传统方法相比，敏捷方法比较适合需求变化大或开发前期对需求部署很清晰的项目）、（敏捷方法的思想是适应性，而不是预设性）、（敏捷方法以原型开放思想为基础，采用迭代式增量开发）</li> <li>在SCRUM中，迭代计划会议的主要议程是（讨论产品代办事项列表最需优先完成的事项）</li> <li>下面不是敏捷开发方法特点的是（软件开发应该遵循严格受控的过程和详细的项目计划）</li> <li>关于Scrum的每一次冲刺（Sprint），正确的有（Sprint是严格不超过4周的迭代，其长度一旦确定，将保持不变）、（Sprint的产出是一个可用的、潜在可发布的产品增量）、（Sprint在进行过程中，其开发目标、质量验收标准和团队组成不能发生变化）</li> <li>（代码审查比运行程序进行测试的效率低）这个说法是错误的，（代码审查用于检查源代码是否达到模块设计的要求）、（代码审查之前必须要成功地编译通过）、（代码审查可以发现不符合团队代码规范的地方）</li> <li>在每日站立会议上，下面（你所遇到问题的原因是什么？）不是每个团队成员需要回答的主要问题</li> <li>下面的（组织每日站立会议）不属于产品负责人的职责范围</li> <li>软件开发瀑布模型中的软件定义时期各个阶段依次是（问题定义，可行性研究，需求分析）</li> <li>瀑布模型是（适用于需求被清晰定义的情况）</li> <li>增量模型是（一种需要快速构造核心产品的创新模型）</li> <li>原型化模型是（适用于客户需求难以清楚定义的情况）</li> <li>软件过程模型有很多种，（功能模型）不是软件过程模型</li> <li>原型化方法是用户和软件开发人员之间进行的一种交互过程，适用于（需求不确定的）系统</li> <li>瀑布模型的主要缺点是（缺乏灵活性）</li> <li>敏捷开发法是一种以团队为核心，自顶向下、循序渐进的开发方法(x) 敏捷开发方法强调的不是团队，而是强调个人和交互。正确的说法是敏捷开发方法强调的是一个由自发写作的个人组成的团队，重视个人和商业需求变化之快速响应，最终带来持续价值的交付</li> <li>敏捷开发适合项目经常发生变更、高风险项目实施、项目规模较小的开发场景</li> <li>敏捷开发法适合对系统有极高的关键性、可靠性、安全性要求的项目开发场景(x)</li></ol></blockquote> <h1 id="敏捷流程"><a href="#敏捷流程" class="header-anchor">#</a> 敏捷流程</h1> <h3 id="非敏捷-瀑布式开发"><a href="#非敏捷-瀑布式开发" class="header-anchor">#</a> 非敏捷——瀑布式开发</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306062212221.png" alt="image.png"></p> <p>瀑布模型的主要缺陷：</p> <ul><li>程序的维护成本会越来越高（需要很多人）</li> <li>团队氛围压抑（感受不到激情）</li> <li>不方便做需求变更（引起客户不满）</li></ul> <h3 id="敏捷过程是什么"><a href="#敏捷过程是什么" class="header-anchor">#</a> 敏捷过程是什么</h3> <ul><li>基于敏捷原则进行的软件开发过程，视为敏捷过程</li> <li>敏捷过程模型
<ul><li><font color="red">极限编程</font></li> <li><font color="red">Scrum</font></li> <li>自适应软件开发（ASD）</li> <li>动态系统开发方法（DSDM）</li> <li>特征驱动开发（FDD）</li> <li>精益软件开发（LSD）</li> <li>敏捷建模AM</li> <li>敏捷统一过程AUP</li></ul></li></ul> <h3 id="极限编程xp"><a href="#极限编程xp" class="header-anchor">#</a> 极限编程XP</h3> <ul><li>极限编程是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一</li> <li>极限编程的主要目标在于降低因需求变更而带来的成本</li> <li>采用迭代的交付方式，每个迭代很短（1-3周时间）。在每个迭代结束的时候，团队交付可运行的，经过测试的功能，这些功能可以马上投入使用</li></ul> <h4 id="xp的过程"><a href="#xp的过程" class="header-anchor">#</a> XP的过程</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306062226672.png" alt="image.png"></p> <ul><li>XP策划
<ul><li>建立一系列描述待开发软件必要特征与功能的“<font color="blue">用户故事</font>”</li> <li>评估每一个故事，并给出以开发周数为度量单位的<font color="red">成本</font></li> <li>客户和XP团队共同决定如何把“<font color="red">故事分组</font>”并置于将要开发的下一个发行版本中（下一个软件增量）</li> <li>形成关于一个发布版本的基本<font color="red">承诺</font></li> <li>在第一个版本发布后，XP团队计算项目的<font color="red">速度</font></li></ul></li> <li>XP设计
<ul><li>严格遵循<font color="red">KIS原则</font>，设计只要能满足系统和客户在当下的需求就可以了，不需要任何画蛇添足的设计</li> <li>鼓励使用<font color="red">CRC卡</font>作为面向对象环境中考虑软件设计的有效机制</li> <li>在某个故事设计中遇到困难时，推荐立即建立<font color="blue">可执行原型</font></li></ul></li> <li>XP编码
<ul><li>鼓励<font color="blue">“测试驱动开发（TDD）”</font></li> <li>鼓励<font color="blue">“结对编程”</font></li> <li>鼓励<font color="blue">“重构”</font></li></ul></li> <li>XP测试
<ul><li>每天进行<font color="red">集成</font>和确认测试（<font color="blue">持续集成</font>）</li> <li><font color="red">“验收测试”</font>由客户确定，根据本次软件发布中所实现的用户故事而确定</li></ul></li></ul> <h3 id="scrum是什么"><a href="#scrum是什么" class="header-anchor">#</a> Scrum是什么</h3> <ul><li>Scrum是一种敏捷开发的模型</li> <li>采用<font color="red">短周期迭代</font>交付模式</li></ul> <p>Scrum流程包括：</p> <ul><li>3个角色
<ul><li>同项目经理类似的<font color="red">Scrum主管</font>：负责维护过程和任务</li> <li><font color="red">产品负责人</font>代表利益所有者</li> <li><font color="red">开发团队</font>包括了所有开发人员</li></ul></li> <li>3个工件
<ul><li>Product Backlog 产品订单（找出产品需要完成的事）</li> <li>Sprint Backlog 冲刺订单（决定当前冲刺需要完成的事）</li> <li>Burndown chart燃尽图</li></ul></li> <li>5个活动
<ul><li>Sprint 冲刺</li> <li>Sprint planning meeting 冲刺计划会</li> <li>Daily standup meeting 每日立会</li> <li>Sprint review 冲刺评审会</li> <li>Retrospective meeting 回顾会议</li></ul></li></ul> <h4 id="敏捷的团队"><a href="#敏捷的团队" class="header-anchor">#</a> 敏捷的团队</h4> <p>敏捷对团队的要求很简单：</p> <ul><li>自主管理</li> <li>自我组织</li> <li>多功能型</li></ul> <h4 id="敏捷的适用范围"><a href="#敏捷的适用范围" class="header-anchor">#</a> 敏捷的适用范围</h4> <table><thead><tr><th>客观因素/最适用方式</th> <th>敏捷</th> <th>计划驱动</th> <th>形式化的开发方法</th></tr></thead> <tbody><tr><td>产品可靠性要求</td> <td>不高，容忍经常出错</td> <td>必须有较高的可靠性</td> <td>有极高的可靠性和质量要求</td></tr> <tr><td>需求变化</td> <td>经常变化</td> <td>不经常变化</td> <td>固定的需求，需求可以建模</td></tr> <tr><td>团队人数</td> <td>不多</td> <td>较多</td> <td>不多</td></tr> <tr><td>人员经验</td> <td>有资深程序员带队</td> <td>以中层技术人员为主</td> <td>资深专家</td></tr> <tr><td>公司文化</td> <td>鼓励变化，行业充满变数</td> <td>崇尚秩序，按时交付</td> <td>精益求精</td></tr> <tr><td><strong>实际例子</strong></td> <td><strong>写一个微博网站；面向消费者的App</strong></td> <td><strong>开发下一版本的办公软件；给商业用户开发软件</strong></td> <td><strong>开发底层正则表达式解析模块；科学计算；复杂系统的核心组件</strong></td></tr></tbody></table> <blockquote><ol><li>燃尽图的作用：用简明的图表展现整个项目的进度</li></ol></blockquote> <h1 id="理解需求"><a href="#理解需求" class="header-anchor">#</a> 理解需求</h1> <h2 id="需求分析为什么困难"><a href="#需求分析为什么困难" class="header-anchor">#</a> 需求分析为什么困难？</h2> <ul><li>客户说不清楚需求</li> <li>需求自身经常变动</li> <li>分析人员或客户理解有误</li></ul> <h2 id="什么是软件需求"><a href="#什么是软件需求" class="header-anchor">#</a> 什么是软件需求</h2> <h3 id="软件需求的定义"><a href="#软件需求的定义" class="header-anchor">#</a> 软件需求的定义</h3> <ul><li>IEEE软件工程中需求的定义
<ol><li>用户解决问题或达到目标所需的条件和能力</li> <li>系统或系统部件为满足合同、标准、规范或其他正式规定文档所需具有的条件和能力</li> <li>以上条件和能力的文档说明</li></ol></li> <li>Sommerville &amp; Sawyer
<ul><li>需求是指系统必须实现什么的规格说明。它描述了系统的行为、特性或属性，是在开发过程中对系统的约束</li></ul></li></ul> <h3 id="软件需求"><a href="#软件需求" class="header-anchor">#</a> 软件需求</h3> <p>软件需求的三个层次</p> <ul><li>业务需求</li> <li>用户需求</li> <li>功能需求
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306072232106.png" alt="image.png"></li></ul> <h4 id="业务需求"><a href="#业务需求" class="header-anchor">#</a> 业务需求</h4> <ul><li>业务需求反映了组织机构或客户对系统、产品高层次的目标要求</li> <li>业务需求从总体上描述了为什么要开发系统，组织希望达到什么目标</li> <li>一般使用前景和范围文档记录业务需求，称作项目轮廓图或市场需求文档</li></ul> <h4 id="用户需求"><a href="#用户需求" class="header-anchor">#</a> 用户需求</h4> <ul><li>用户需求描述了用户使用产品必须要完成的任务</li> <li>用例、场景描述和事件——响应表都是表达用户需求的有效途径</li> <li>在问题定义的基础上进行用户访谈、调查，对用户使用 场景进行整理，从而建立用户角度的需求</li> <li>描述了用户能使用系统来做什么</li></ul> <h4 id="功能需求"><a href="#功能需求" class="header-anchor">#</a> 功能需求</h4> <ul><li>系统分析员描述开发人员在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求</li> <li>功能需求是需求的主体，它描述的是开发人员如何设计具体的解决方案来实现这些用户需求，其数量往往比用户需求高一个数量级</li> <li>这些需求记录在软件需求规格说明SRS中</li></ul> <h2 id="软件需求的分类"><a href="#软件需求的分类" class="header-anchor">#</a> 软件需求的分类</h2> <p><strong>功能需求</strong>：描述系统预期提供的功能或服务</p> <ul><li>系统应提供的服务</li> <li>系统如何对输入做出反应</li> <li>系统在特定的条件下的行为</li> <li>系统不应该做什么</li></ul> <p><strong>非功能需求</strong>：不直接与系统具体功能相关的需求</p> <ul><li>产品需求：产品行为的需求，包括性能需求、可靠性需求和可用性需求等</li> <li>机构需求：客户和开发者所在机构中的政策和规定要求，如过程标准、实现要求、交付需求</li> <li>外部需求：所有的系统外部因素要求，如互操作需求</li></ul> <h2 id="需求工程"><a href="#需求工程" class="header-anchor">#</a> 需求工程</h2> <ul><li>应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有<font color="red">外部特征</font>的一门学科</li> <li>它通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断<font color="red">变化的需求</font>演进给予支持</li></ul> <h3 id="需求工程的基本活动"><a href="#需求工程的基本活动" class="header-anchor">#</a> 需求工程的基本活动</h3> <ul><li><p><font color="red">起始</font>——询问一系列问题，以确定：</p> <ul><li>对问题的基本理解</li> <li>谁需要解决方案</li> <li>所期望解决方案的性质</li></ul></li> <li><p><font color="red">导出</font>——从所有利益相关者处获取需求</p></li> <li><p><font color="red">精化</font>——创建一个分析模型，定义问题的信息域、功能域和行为域</p></li> <li><p><font color="red">协商</font>——通过协商过程来调解客户提出的<font color="red">过高</font>的目标要求和相互<font color="red">冲突</font>的需求</p></li> <li><p><font color="red">规格说明</font>——需求分析师的工作产品，为以下一种或几种：写好的文档、图形化的模型、形式化的模型、形式化的数学模型、一组用户场景（用例）、原型</p> <ul><li>两种需求文档
<ul><li><font color="red">需求定义</font>：客户要求的完整列表
<ul><li>通常由<font color="red">客户</font>和<font color="red">需求分析师</font>一起编写，是开发人员对系统功能的一个合同，主要给<font color="red">客户</font>阅读</li></ul></li> <li><font color="red">需求规格说明</font>：要构建系统的规格化说明
<ul><li>由<font color="red">需求分析师</font>编写，并由其他<font color="red">软件开发人员</font>使用</li></ul></li></ul></li></ul></li> <li><p><font color="red">确认</font>——通过评审机制，寻找：</p> <ul><li>内容或解释上的差错</li> <li>可能需要进一步澄清的地方</li> <li>丢失的信息</li> <li>不一致（开发大型系统时的主要问题）</li> <li>冲突或不现实的需求</li></ul></li> <li><p><font color="red">需求管理</font></p> <ul><li>在项目执行过程中标识、控制和跟踪需求以及变更需求</li></ul></li> <li><p>在实际的开发过程中，获取、建模、编写规约和验证这些需求开发活动不会是线性地、顺序地完成。实际上，这些活动是交叉的、递增的和反复的。
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306091358001.png" alt="image.png"></p></li></ul> <h2 id="需求获取技术"><a href="#需求获取技术" class="header-anchor">#</a> 需求获取技术</h2> <ul><li>面谈</li> <li>调查</li> <li>观察实际业务过程</li> <li>原型法</li> <li>头脑风暴</li> <li>场景技术</li></ul> <p><strong>面谈</strong></p> <ul><li>面对面交流是理解业务功能和规则的最有效方法</li> <li>该方法比较耗时和资源</li> <li>项目组成员与单个用户或用户组举行会议</li> <li>面谈步骤：
<ul><li>阅读背景资料</li> <li>确定面谈目标</li> <li>决定面谈对象</li> <li>和面谈对象沟通</li> <li>整理面谈报告</li></ul></li> <li>非正式面谈和正式面谈</li></ul> <p><strong>调查技术</strong></p> <ul><li>向客户组织的相关人员发放调查表</li> <li>关键：确定调查内容
<ul><li>非正式会谈</li> <li>制定调查表</li> <li>组织调查</li></ul></li> <li>使用场合：
<ul><li>系统相关者较多</li> <li>地理上分布广</li></ul></li></ul> <p><strong>观察实际业务过程</strong></p> <ul><li>观察并记录业务流程
<ul><li>同用户进行交谈</li> <li>观察：有效收集信息的另一种方法</li> <li>方式：直接在用户工作的地方观察他们的日常活动并记录下观察到的业务操作过程</li></ul></li> <li>观察方法
<ul><li>对办公室进行快速浏览</li> <li>安排一定的时间观察用户的工作过程</li> <li>同用户一道亲身实践体会工作过程</li></ul></li> <li>使用工作流图来进行记录
<ul><li>工作流——处理商业事务或客户请求的一系列步骤</li> <li>工作流图：流程图、数据流图、活动图</li></ul></li></ul> <p><strong>原型法</strong></p> <ul><li>软件原型是一种软件系统的局部实现技术，可以帮助软件开发人员、用户和客户更好地理解软件需求</li> <li>使用原型的主要目的：
<ul><li>明确并完善需求</li> <li>探索设计选择方案</li> <li>发展为最终的产品原型</li></ul></li></ul> <p><strong>头脑风暴</strong></p> <ul><li>一群人围绕一个特定的兴趣领域使用没有拘束的规则开展团队讨论。提供一个能激发灵感、开阔思路的环境</li> <li>特点
<ul><li>自由畅谈</li> <li>延迟评判</li> <li>禁止批评</li> <li>追求数量</li></ul></li></ul> <p><strong>基于场景的需求捕获方法</strong></p> <ul><li>也称为情景实例的分析方法</li> <li>基于对应用环境的某一特定情景的描述来阐述用户的需求</li> <li>从场景的结构化描述中抽取活动图、场景、角色、数据关系图等，从而形成需求模型</li></ul> <h2 id="竞争性需求分析"><a href="#竞争性需求分析" class="header-anchor">#</a> 竞争性需求分析</h2> <h3 id="竞争性需求分析nabcd-model"><a href="#竞争性需求分析nabcd-model" class="header-anchor">#</a> 竞争性需求分析NABCD model</h3> <p><strong>N（Need 需求）</strong>
你的创意解决了用户的什么需求？
<strong>A（Approach 做法）</strong>
你有什么招数，特别是独特的招数，来解决用户的痛苦
<strong>B（Benefit 好处）</strong>
那你这个产品能给用户带来什么好处？
<strong>C（Competitors 竞争）</strong>
与竞争对手相比你有什么优势
<strong>D（Delivery）</strong>
你怎么让目标用户都知道你的产品？并且让产品的用户量快速提高？</p> <h2 id="需求规格说明书"><a href="#需求规格说明书" class="header-anchor">#</a> 需求规格说明书</h2> <h3 id="需求规格说明书的作用"><a href="#需求规格说明书的作用" class="header-anchor">#</a> 需求规格说明书的作用</h3> <ol><li>便于用户、分析人员和软件设计人员进行理解和交流</li> <li>作为软件设计的基础</li> <li>作为验收的依据</li></ol> <h3 id="需求规格说明语言"><a href="#需求规格说明语言" class="header-anchor">#</a> 需求规格说明语言</h3> <ul><li>自然语言
<ul><li>是最自然的描述需求规格说明的语言</li> <li>描述的内容会产生二义性，并造成软件需求理解上的错误</li></ul></li> <li>形式化语言
<ul><li>基于数学方法而提出的一种抽象描述语言，具有严格的语法和语义</li> <li>需要具有较好的数学基础和经过严格的专门训练</li></ul></li> <li>结构化语言
<ul><li>介于自然语言和形式语言之间的语言</li> <li>也称为半形式语言</li></ul></li></ul> <h3 id="需求规格的主要内容"><a href="#需求规格的主要内容" class="header-anchor">#</a> 需求规格的主要内容</h3> <ul><li>对目标软件的各种描述
<ul><li>信息描述</li> <li>功能和行为描述</li> <li>性能需求</li> <li>设计约束</li> <li>合适的验收标准</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230609165157.png" alt="image.png"></p> <blockquote><ol><li>需求有哪三个层次？
答：业务需求、用户需求、功能需求</li> <li>需求可分为哪些类型
答：功能需求、非功能需求</li> <li>需求获取技术有哪些？
答：面谈、调查、观察实际业务过程、头脑风暴、原型法、场景技术</li> <li>需求规格主要有哪些内容？
答：对目标软件的各种描述：信息描述、功能和行为描述、性能需求、设计约束、合适的验收标准</li></ol></blockquote> <h1 id="需求建模"><a href="#需求建模" class="header-anchor">#</a> 需求建模</h1> <p><strong>需求过程</strong></p> <ul><li>获取需求</li> <li>细化（需求分析）</li> <li>协商</li> <li>编写需求规格说明</li> <li>确认需求</li> <li>需求管理</li></ul> <h2 id="需求建模概述"><a href="#需求建模概述" class="header-anchor">#</a> 需求建模概述</h2> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <ul><li>需求分析的目的：
<ul><li>说明软件的工作特征</li> <li>指明软件和其他系统元素的接口</li> <li>规定软件必须满足的约束</li></ul></li> <li>需求分析的主要任务：
<ul><li>细化在前期需求工程的基础需求</li> <li>构建一种或多种模型以<font color="red">描述用户场景、功能活动、类、类之间的关系、系统和类的行为、数据流等</font></li></ul></li> <li>需求建模的总体目标:
<ul><li>描述客户需要什么</li> <li>为软件设计奠定基础</li> <li>定义在软件完成后可以被确认的一组需求</li></ul></li></ul> <h3 id="需求建模的经验原则"><a href="#需求建模的经验原则" class="header-anchor">#</a> 需求建模的经验原则</h3> <ul><li>模型应关注在问题域或业务域内<font color="red">可见的需求</font>，抽象的级别应该相对高一些</li> <li>需求模型的每个元素都应能增加对软件需求的整体理解，并提供对信息域、功能和系统行为的深入理解</li> <li>关于基础结构和其他非功能的模型应推延到设计阶段再考虑</li> <li>最小化整个系统内的关联</li> <li>确认需求模型为所有相关利益者都带来价值</li> <li>尽可能保持模型简洁</li></ul> <h3 id="需求建模的元素"><a href="#需求建模的元素" class="header-anchor">#</a> 需求建模的元素</h3> <ul><li>场景模型
<ul><li>出自各种系统“参与者”观点的需求</li></ul></li> <li>数据模型
<ul><li>描述问题信息域的模型（用于建立数据库）</li></ul></li> <li>类模型
<ul><li>表示面向对象类（属性和操作）的模型</li></ul></li> <li>数据流模型
<ul><li>描述功能元素在系统中运行时怎样进行数据变换</li></ul></li> <li>行为模型
<ul><li>描述系统的外部行为</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306091936091.png" alt="image.png"></p> <h2 id="基于场景的建模"><a href="#基于场景的建模" class="header-anchor">#</a> 基于场景的建模</h2> <h3 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h3> <ul><li>用例：
<ul><li>用于表示系统所提供的服务，描述参与者为了使用系统所提供的某一完整功能而与系统之间发生的一段对话（交互）</li></ul></li> <li>场景：
<ul><li>场景是用例的实例化，从一个用例可以实例化出来多个用例场景。用例就是对全部场景的抽象</li></ul></li></ul> <h3 id="用例建模步骤"><a href="#用例建模步骤" class="header-anchor">#</a> 用例建模步骤</h3> <ul><li>识别系统的参与者（执行者，actor）</li> <li>识别用例</li> <li>绘制用例图</li> <li>编写用例描述</li></ul> <h3 id="用例建模案例-出卷系统"><a href="#用例建模案例-出卷系统" class="header-anchor">#</a> 用例建模案例——出卷系统</h3> <h4 id="原始需求"><a href="#原始需求" class="header-anchor">#</a> 原始需求</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306092003483.png" alt="image.png"></p> <h4 id="识别参与者"><a href="#识别参与者" class="header-anchor">#</a> 识别参与者</h4> <ul><li>教师</li> <li>学生</li> <li>题库维护人员</li></ul> <h4 id="识别用例-从参与者出发"><a href="#识别用例-从参与者出发" class="header-anchor">#</a> 识别用例（从参与者出发）</h4> <ul><li>教师：希望能够方便地出一份合理的试卷并输出</li> <li>学生：希望能够生成一些模拟试卷来在线练习，检查学习结果</li> <li>题库维护人员：维护题库</li></ul> <h4 id="细化用例"><a href="#细化用例" class="header-anchor">#</a> 细化用例</h4> <ul><li>教师：希望能够方便地出一份合理的试卷
<ul><li>自动组卷</li> <li>手动组卷</li> <li>编辑试卷</li> <li>输出试卷</li></ul></li> <li>学生：希望能够通过生成一些模拟试卷来在线练习，检查学习结果
<ul><li>随机组卷</li> <li>在线练习</li> <li>自动评分</li></ul></li> <li>题库维护人员：试题管理（增加试题、编辑试题、删除试题）</li></ul> <h4 id="编写用例描述"><a href="#编写用例描述" class="header-anchor">#</a> 编写用例描述</h4> <p><font color="red">用例名称：</font>表明用例的用途，如图书管理系统中的“借阅图书”、“归还图书”
<font color="red">标识符：</font>「可选」用于唯一标识某个实体或对象的名称或代码，例如“UC200601”。
<font color="red">参与者：</font>「可选」与此用例相关的参与者列表
<font color="red">简要说明：</font>对该用例进行说明，描述用例作用。注意语言简要，使用自然语言
<font color="red">前置条件：</font>用例执行必须满足的条件
<font color="red">后置条件：</font>用例成功完成后系统处于什么状态
<font color="red">基本事件流：</font>描述参与者和系统的交互
<font color="red">扩展事件流：</font>在变更工作方式、出现异常或发生错误的情况下所遵循的步骤</p> <h4 id="补充用例的uml模型"><a href="#补充用例的uml模型" class="header-anchor">#</a> 补充用例的UML模型</h4> <h5 id="活动图"><a href="#活动图" class="header-anchor">#</a> 活动图</h5> <p>UML活动图在特定场景内通过提供迭代流的图形化表示来补充用例。类似于流程图，活动图<font color="red">使用两端为半圆形的矩形表示一个特定的系统功能</font>，<font color="green">箭头表示通过系统的流</font>，<font color="blue">判定菱形表示判定分支（标记从菱形发出的每个箭头）</font>，<font color="orange">实心水平线意味着并行发生的活动</font>。</p> <h5 id="泳道图"><a href="#泳道图" class="header-anchor">#</a> 泳道图</h5> <p>UML泳道图是活动图的一种有用的变形，可让建模人员表示用例所描述的活动流，同时指示哪个参与者（若在某个特定用例中涉及了多个参与者）或分析类是由活动矩形所描述的活动来负责。职责由纵向分割图的并行条来表示，就像泳池的泳道。</p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230611105319.png" alt="image.png"></p> <h2 id="基于数据流的建模"><a href="#基于数据流的建模" class="header-anchor">#</a> 基于数据流的建模</h2> <h3 id="结构化方法概述"><a href="#结构化方法概述" class="header-anchor">#</a> 结构化方法概述</h3> <ul><li>一种<font color="red">面向数据流</font>的传统软件开发方法</li> <li>以数据流为中心构建软件的<font color="red">分析模型</font>和<font color="red">设计模型</font></li> <li>分为：
<ul><li><font color="red">结构化分析（简称SA）</font></li> <li><font color="red">结构化设计（简称SD）</font></li> <li><font color="red">结构化程序设计（简称SP）</font></li></ul></li></ul> <h3 id="结构化分析方法"><a href="#结构化分析方法" class="header-anchor">#</a> 结构化分析方法</h3> <p>主要思想：抽象与自顶向下的逐层分解（控制复杂性的两个基本手段）</p> <h3 id="抽象与分解"><a href="#抽象与分解" class="header-anchor">#</a> 抽象与分解</h3> <ul><li>抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面</li> <li>分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止</li> <li>随着分解层次的增加，抽象的级别越来越低，也越接近问题的解（算法和数据结构）
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306112029641.png" alt="image.png"></li></ul> <h3 id="结构化分析模型"><a href="#结构化分析模型" class="header-anchor">#</a> 结构化分析模型</h3> <p>系统模型不同的角度表述系统：</p> <ul><li>从外部来看，对系统分析上下文或系统环境建模</li> <li>从行为上看，对系统行为建模</li> <li>从结构上看，对系统的体系结构和系统处理的数据结构建模</li></ul> <p>结构化的需求分析模型：</p> <ul><li><font color="red">功能模型（数据流模型）</font>，用来描述系统中的数据处理过程</li> <li><font color="red">行为模型（状态转换模型）</font>，用来描述系统如何对事件做出响应</li> <li><font color="red">数据模型（实体——关系模型）</font>，用来描述系统中的数据及其之间的关系</li></ul> <h4 id="结构化分析模型结构"><a href="#结构化分析模型结构" class="header-anchor">#</a> 结构化分析模型结构</h4> <ul><li><font color="red">数据字典</font>是模型的核心，它包含了软件使用和产生的所有数据的描述</li> <li><font color="red">数据流图（DFD）</font>，服务于两个目的：一是指明数据在系统中移动时如何被变换，二是描述对数据流进行变换的功能和子功能
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306112101538.png" alt="image.png"></li></ul> <h3 id="数据流图符号"><a href="#数据流图符号" class="header-anchor">#</a> 数据流图符号</h3> <p>Data Flow Diagram（简称<font color="red">DFD</font>）：描述输入数据流到输出数据流的变换（即加工、处理）过程，用于对系统的功能建模，基本元素包括：</p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306121111144.png" alt="image.png"></p> <h3 id="数据流图举例"><a href="#数据流图举例" class="header-anchor">#</a> 数据流图举例</h3> <blockquote><p>设一个工厂采购部每天需要一张订货报表。订货的零件数据有：零件编号、名称数量、价格、供应者等。零件的入库、出库事务由仓库管理员通过计算机终端输入个订货系统。当某零件的库存数少于给定的库存量临界值时，就应该再次订货。</p></blockquote> <ul><li>数据流分析：
<ul><li>数据源点：仓管员（负责入库或出库事务给定货系统）</li> <li>数据终点：采购员（接收每天的订货报表）</li> <li>数据流：事务，订货报表</li> <li>数据存储：订货信息，库存清单</li></ul></li></ul> <h3 id="数据流图的各个层次"><a href="#数据流图的各个层次" class="header-anchor">#</a> 数据流图的各个层次</h3> <ul><li>顶层图（第0层）只有代表整个软件系统的1个加工，描述了软件系统与外界之间的数据流</li> <li>顶层图中的加工经分解后的图称为第1层图（只有1张）</li> <li>中间层图中至少有一个加工（也可以有多个）在下层图中分解成一张<font color="red">子图</font></li> <li>处理最底层的图称为底层图，其中所有的加工不再分解成新的子图</li></ul> <h3 id="图和加工的编号"><a href="#图和加工的编号" class="header-anchor">#</a> 图和加工的编号</h3> <ul><li>顶层图只有一个代表整个软件系统的加工，该加工不必编号</li> <li>第1层图中的加工编号分别为1，2，3，....</li> <li>子图号：若父图中的加工号x分解成某一子图，则该子图号记为“图x”</li> <li>子图中加工的编号：若父图中的加工号为x的加工分解成某一子图，则该子图中的加工编号分别为下x.1、x.2、x.3...</li></ul> <h3 id="分层数据流图示例-资格和水平考试的考务处理系统"><a href="#分层数据流图示例-资格和水平考试的考务处理系统" class="header-anchor">#</a> 分层数据流图示例——资格和水平考试的考务处理系统</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306121503874.png" alt="image.png"></p> <h4 id="资格和水平考试的考务处理系统-功能需求"><a href="#资格和水平考试的考务处理系统-功能需求" class="header-anchor">#</a> 资格和水平考试的考务处理系统——功能需求</h4> <ul><li>对<font color="red">考生</font>送来的<font color="red">报名单</font>进行检查</li> <li>对合格的报名单编好准考证号后将<font color="red">准考证</font>给<font color="red">考生</font>，并将汇总后的<font color="red">考生名单</font>送给<font color="red">阅卷站</font></li> <li>对<font color="red">阅卷站</font>送来的<font color="red">成绩清单</font>进行检查，并根据考试中心制定的<font color="red">合格标准</font>审定合格者</li> <li>制定<font color="red">考生通知单</font>送个<font color="red">考生</font></li> <li>进行成绩分类统计（按地区、年龄、文化程度、职业、考试级别等分类）和试题难度分析，产生<font color="red">统计分析表</font></li></ul> <h4 id="画顶层图"><a href="#画顶层图" class="header-anchor">#</a> 画顶层图</h4> <ul><li>确定源点和终点</li> <li>确定顶层图的加工</li> <li>确定数据流（系统的输入/输出信息）</li> <li>确定存储</li></ul> <h5 id="画系统的输入输出-顶层图"><a href="#画系统的输入输出-顶层图" class="header-anchor">#</a> 画系统的输入输出（顶层图）</h5> <ul><li>确定源点和终点：<font color="red">考生、阅卷站和考试中心</font> <ul><li>它们都既是源点又是终点</li></ul></li> <li>顶层图唯一的加工：<font color="red">软件系统（考务处理系统）</font></li> <li>确定数据流：系统的输入/输出信息
<ul><li>输入数据流：<font color="red">报名单（来自考生）、成绩清单（来自阅卷站）、合格标准（来自考试中心）</font></li> <li>输出数据流：<font color="red">准考证（送往考生）、考生名单（送往阅卷站）、考生通知书（送往考生）、统计分析表（送往考试中心）</font></li> <li>额外的输出流（考虑系统的健壮性）：<font color="green">不合格报名单（返回给考生），错误成绩清单（返回给阅卷站）</font></li></ul></li> <li>顶层图通常没有文件</li></ul> <h5 id="考务处理系统1层图"><a href="#考务处理系统1层图" class="header-anchor">#</a> 考务处理系统1层图</h5> <p>根据功能需求对功能进行分解：考务处理系统可分为两部分
一、考试报名</p> <ol><li>对考生送来的报名单进行检查</li> <li>对合格的报名单编号准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站
<font color="red">需要增加存储：考生名册</font></li></ol> <p>二、统计成绩</p> <ol><li>对阅卷站送来的成绩清单进行检查，并根据考试中心制定的合格标准审定合格者</li> <li>制定考生通知书给考生</li> <li>进行成绩分类统计（按地区、年龄、文化程度、职业、考试级别等分类）和试题难度分析，产生统计分析表</li></ol> <h5 id="考务处理系统加工1子图"><a href="#考务处理系统加工1子图" class="header-anchor">#</a> 考务处理系统加工1子图</h5> <ul><li>加工1：“考试报名”对应的功能需求：
<ul><li>对考试送来的报名单进行检查</li> <li>对合格的报名单编好准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站</li></ul></li> <li>分解：
<ul><li>检查报名单</li> <li>编准考证号：编准考证号并将准考证送给考生</li> <li>登记考生：保存考生信息并将考生名单送给阅卷站</li></ul></li> <li>3个子加工：检查报名单、编准考证号、登记考生</li> <li>“合格报名单”和“正式报名单”是新增加的数据流，其他数据流是加工1原有的</li> <li>在加工1的分解中没有新的文件产生</li></ul> <h5 id="考务处理系统加工2子图"><a href="#考务处理系统加工2子图" class="header-anchor">#</a> 考务处理系统加工2子图</h5> <ul><li>加工2：“统计成绩”对应的功能需求：
<ul><li>对阅卷站送来的成绩清单进行检查，并根据考试中心制订的合格标准审定合格者</li> <li>制作考生通知单送给考生</li> <li>进行成绩分类统计(按地区、年龄、文化程度、职业、考试级别等分类)和试题难度分析，产生统计分析表</li></ul></li> <li>分解：
<ul><li>检查成绩清单</li> <li>审定合格者</li> <li>制定考生通知单</li> <li>分类统计成绩</li> <li>分析试题难度</li></ul></li></ul> <h3 id="课堂练习"><a href="#课堂练习" class="header-anchor">#</a> 课堂练习</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306122145150.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306122148347.png" alt="image.png"></p> <h3 id="总结-画分层数据流图的步骤"><a href="#总结-画分层数据流图的步骤" class="header-anchor">#</a> 总结：画分层数据流图的步骤</h3> <ol><li>画系统的输入和输出</li> <li>画系统内部</li> <li>画加工内部</li> <li>重复第3步，直至每个尚未分解的加工都足够简单（即不必再分解）</li></ol> <h3 id="数据字典"><a href="#数据字典" class="header-anchor">#</a> 数据字典</h3> <ul><li>数据流图与数据字典是密不可分的，两者结合起来构成软件的逻辑模型（分析模型）</li> <li>数据字典由字典条目组成，每个条目描述DFD中的一个元素</li> <li>数据字典条目包括：数据流、文件、数据项（组成数据流和文件的数据）、加工、源点和终点</li></ul> <h3 id="定义数据组成的符号"><a href="#定义数据组成的符号" class="header-anchor">#</a> 定义数据组成的符号</h3> <table><thead><tr><th>符号</th> <th>名称</th> <th>举例</th></tr></thead> <tbody><tr><td>=</td> <td>定义为</td> <td>x = ...    表示x由...组成</td></tr> <tr><td>+</td> <td>与</td> <td>a + b     表示a和b</td></tr> <tr><td>[..., ...]</td> <td>或</td> <td>[a, b]    表示a或b</td></tr> <tr><td>[... | ...]</td> <td>或</td> <td>[a | b]    表示a或b</td></tr> <tr><td>{...}</td> <td>重复</td> <td>{a}    表示a重复0次或多次</td></tr> <tr><td>{...}<sub>m</sub><sup>n</sup></td> <td>重复</td> <td>{a}<sub>3</sub><sup>8</sup>    表示a重复3到8次</td></tr> <tr><td>(...)</td> <td>可选</td> <td>(a)    表示a重复0或1次</td></tr> <tr><td>&quot;...&quot;</td> <td>基本数据元素</td> <td>&quot;a&quot;    表示a是基本数据</td></tr></tbody></table> <h3 id="数据流组成示例-学校电话号码"><a href="#数据流组成示例-学校电话号码" class="header-anchor">#</a> 数据流组成示例（学校电话号码）</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230613104542.png" alt="image.png">
电话号码 = [校内电话 | 本市电话 | 外地电话]
校内电话 = {非0数字}<sub>1</sub><sup>1</sup> + {数字}<sub>3</sub><sup>3</sup>
本市电话 = 0 + {非0数字}<sub>1</sub><sup>1</sup> + {数字}<sub>7</sub><sup>7</sup>
外地电话 = 0 + {数字}<sub>3</sub><sup>3</sup> + {非0数字}<sub>1</sub><sup>1</sup> + {数字}<sub>7</sub><sup>7</sup></p> <h3 id="数据流组成示例-发票"><a href="#数据流组成示例-发票" class="header-anchor">#</a> 数据流组成示例（发票）</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230613110920.png" alt="image.png"></p> <p>发票 = 单位名称 + {商品 + 数量 + 单价 + 金额}<sub>1</sub><sup>5</sup> + 总金额 + 日期 + (营业员)</p> <h3 id="字典条目"><a href="#字典条目" class="header-anchor">#</a> 字典条目</h3> <ul><li>不同的开发组织或团队可以根据项目的需要定义字典条目的描述内容</li> <li>字典条目中的描述内容包括
<ul><li>DFD元素的基本信息（名称、别名、简述、注解）</li> <li>定义（数据类型、数据组成）</li> <li>使用特点（取值范围、使用频率、激发条件）</li> <li>控制信息（来源、去向、访问权限）等</li></ul></li></ul> <h3 id="数据流条目的描述内容"><a href="#数据流条目的描述内容" class="header-anchor">#</a> 数据流条目的描述内容</h3> <ul><li>名称：数据流名</li> <li>别名：名称的另一个名字</li> <li>简述：对数据流的简单说明</li> <li>数据流组成：描述数据流由哪些数据项组成</li> <li>数据流来源：描述数据流从哪个加工或源点流出</li> <li>数据流去向：描述数据流流入哪个加工或终点</li> <li>数据量：系统中该数据流的总量
<ul><li>如考务处理系统中“报名单”的总量是1000000张</li> <li>或者单位时间处理的数据流数量，如8000张/天</li></ul></li> <li>峰值：某时段处理的最大数量
<ul><li>如每天上午9:00至11:00处理60000张表单</li></ul></li> <li>注解：对该数据流的其它补充说明</li></ul> <h3 id="数据流组成"><a href="#数据流组成" class="header-anchor">#</a> 数据流组成</h3> <ul><li>数据流组成是数据条目的核心，它列出组成该数据流的各项数据项，例如：
<ul><li>培训报名单 = 姓名 + 单位 + 课程</li> <li>运动员报名单=队名+姓名+性别+{参赛项目}<sub>1</sub><sup>3</sup></li></ul></li> <li>当一个数据流组成比较复杂时，可以将其分解成几个数据流，例如：
<ul><li>课程 = 课程名 + 任课教师 + 教材 + 时间地点</li> <li>时间地点 = {星期几 + 第几节 + 教室}</li></ul></li></ul> <h3 id="文件条目的描述内容"><a href="#文件条目的描述内容" class="header-anchor">#</a> 文件条目的描述内容</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230613115438.png" alt="image.png"></p> <h3 id="数据项条目的描述内容"><a href="#数据项条目的描述内容" class="header-anchor">#</a> 数据项条目的描述内容</h3> <ul><li>名称：数据项名</li> <li>别名：名称的另一个名字</li> <li>简述：对数据项的简单描述</li> <li><font color="red">数据类型</font>：描述数据项的类型，如整型、实型、字符串等</li> <li><font color="red">计量单位</font>：指明数据项的计量单位，如公斤、吨等</li> <li><font color="red">取值范围</font>：描述数据项允许的值域，如1...100</li> <li>编辑方式：描述该数据项外部表示的编辑方式，如23，345.67</li> <li>与其他数据项的关系：描述该数据项与数据字典中其它数据项的关系</li> <li>注解：对数据项的其他补充说明</li></ul> <h3 id="加工条目的描述内容"><a href="#加工条目的描述内容" class="header-anchor">#</a> 加工条目的描述内容</h3> <ul><li>名称：加工名</li> <li>别名：名称的另一个名字</li> <li><font color="red">加工号</font>：加工在DFD中的编号</li> <li><font color="red">简述</font>：对加工的功能的简要说明</li> <li>输入数据流：描述加工的输入数据流，包括读哪些文件</li> <li>输出数据流：描述加工的输出数据流，包括写哪些文件</li> <li>加工逻辑：简要描述加工逻辑</li> <li>异常处理：描述加工处理过程中可能出现的异常情况，及其处理方式</li> <li>加工激发条件：描述执行加工的条件，如“身份认证正确”，“收到报名单”</li> <li>执行频率：描述加工的执行频率，如每月执行一次，每天0点执行</li> <li>注解：对加工的其它补充说明</li></ul> <h3 id="源点或终点条目的描述内容"><a href="#源点或终点条目的描述内容" class="header-anchor">#</a> 源点或终点条目的描述内容</h3> <ul><li><font color="red">名称</font>：源点或终点的名称（外部实体名）</li> <li>别名：名称的了一个名字</li> <li><font color="red">简要描述</font>：对源点或终点的简要描述（包括指明该外部实体在DFD中是用作“源点”，还是“终点”，还是“既是源点又是终点”）</li> <li>输入数据流：描述源点向系统提供哪些输入数据流</li> <li>输出数据流：描述系统向终点提供哪些输出数据流</li> <li>注解：对源点或终点的其他补充说明</li></ul> <h2 id="基于数据的建模"><a href="#基于数据的建模" class="header-anchor">#</a> 基于数据的建模</h2> <h3 id="面向数据的建模方法"><a href="#面向数据的建模方法" class="header-anchor">#</a> 面向数据的建模方法</h3> <ul><li>建立系统的数据模型</li> <li>数据建模——是一种面向问题领域的数据模型，是按照用户观点对数据建立的模型。它描述了从用户角度看到的数据，反映了用户的现实环境，而且与在软件系统中的实现方法无关</li> <li>数据模型中包含3种互相关联的信息：数据对象（实体）、数据对象的属性及数据对象彼此间相互连接的关系</li></ul> <h4 id="数据对象"><a href="#数据对象" class="header-anchor">#</a> 数据对象</h4> <ul><li>数据对象：是对软件必须理解的复合信息的抽象</li> <li>数据对象可以由一组属性来定义</li> <li>如：外部实体、事物、行为、事件、角色、单位、地点或结构等</li> <li>数据对象彼此间是有关联的</li></ul> <h4 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h4> <ul><li>属性定义了数据对象的性质</li> <li>必须把一个或多个属性定义为“标识符”，也就是说，当我们希望找到数据对象的一个实例时，用标识符属性作为“关键字”（通常）</li> <li>应该根据对所要解决的问题的理解，来确定特定数据对象的一组合适的属性</li> <li>如：学生具有学号、姓名、性别、年龄、专业（其他略）等熟悉</li> <li>课程具有课程号、课程名、学分、学时数等属性</li> <li>教师具有职工号、姓名、年龄、职称等属性</li></ul> <h4 id="联系"><a href="#联系" class="header-anchor">#</a> 联系</h4> <ul><li>数据对象彼此之间互相连接的方式称为联系，也称为关系。联系可分为以下3种类型：
<ul><li>a. 一对一联系（1 : 1）
<ul><li>如：一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的</li></ul></li> <li>b. 一对多联系（1 : N）
<ul><li>如：某校教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位老师来教</li></ul></li> <li>c. 多对多联系（M : N）
<ul><li>如：学生与课程间的联系（“学”）是多对多的，即一个学生可以学多门课程，而每门课程可以有多名学生来学。联系也可能有属性</li> <li>如学生“学”某门课程所取得的成绩，既不是学生的属性也不是课程的属性。由于“成绩”既依赖于某名特定的学生又依赖于某门特定的课程，所以它是学生与课程之间的联系“学”的属性</li></ul></li></ul></li></ul> <h4 id="实体-联系图-er图"><a href="#实体-联系图-er图" class="header-anchor">#</a> 实体——联系图（ER图）</h4> <ul><li>ER图——是用来建立数据模型的工具</li> <li>ER图中包含了<font color="red">实体（即数据对象）、关系和属性</font>等3种基本成分</li> <li>通常用<font color="red">矩形框代表实体</font></li> <li>用连接相关实体的<font color="red">菱形框表示关系</font></li> <li>用<font color="red">椭圆形或圆角矩形代表实体（或关系）的属性</font></li> <li>并用<font color="red">直线</font>把<font color="green">实体（或关系）与其属性</font>连接起来</li></ul> <h4 id="练习"><a href="#练习" class="header-anchor">#</a> 练习</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306131545840.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306131611894.png" alt="image.png"></p> <p><strong>数据字典——数据流条目“出卷要求”</strong></p> <ul><li>名称：出卷要求</li> <li>别名：无</li> <li>简述：教师对组卷的具体要求</li> <li>数据流组成：<font color="red">{知识点 + 题型 + 难度 + 数量 + 分值}<sub>1</sub><sup>n</sup></font></li> <li>数据流来源：“获得出卷要求”加工</li> <li>数据流去向：“审查出卷要求”加工</li> <li>注解：
<ul><li>数据流示例：</li></ul></li></ul> <table><thead><tr><th>知识点</th> <th>题型</th> <th>难度</th> <th>出题数量</th> <th>分值</th></tr></thead> <tbody><tr><td>选择结构</td> <td>选择题</td> <td>低</td> <td>4</td> <td>4</td></tr> <tr><td>循环结构</td> <td>选择题</td> <td>中</td> <td>10</td> <td>10</td></tr> <tr><td>指针</td> <td>编程题</td> <td>高</td> <td>5</td> <td>20</td></tr></tbody></table> <h3 id="面向状态的建模方法"><a href="#面向状态的建模方法" class="header-anchor">#</a> 面向状态的建模方法</h3> <p>状态模型是一种描述系统对内部或者外部事件响应的行为模型
它描述系统状态和事件，以及事件引发系统在状态间的转换
这种模型适用于描述实时系统
状态建模方法步骤：</p> <ul><li>系统状态、行为与时间分析</li> <li>构建状态图</li></ul> <h4 id="状态转换图"><a href="#状态转换图" class="header-anchor">#</a> 状态转换图</h4> <ul><li>状态转换图（简称为状态图）
通过描述系统的<font color="red">状态</font>及引起系统状态转换的<font color="red">事件</font>，来表示系统的<font color="red">行为</font>。此外，状态图还指明了作为特定事件的结果系统将做哪些动作（例如，处理数据）
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306131700388.png" alt="image.png"></li></ul> <h4 id="状态"><a href="#状态" class="header-anchor">#</a> 状态</h4> <ul><li><font color="red">状态</font>是任何可以被观察到的<font color="red">系统行为模型</font>，一个状态代表系统的一种行为模式。<font color="red">状态规定了系统对事件的响应方式</font>。系统对事件的响应，既可以是做一个（或一系列）动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态又做动作</li> <li>三种状态：<font color="red">初态（即初始状态）</font>、<font color="green">终态（即最终状态）</font>、<font color="blue">中间态</font></li> <li>一张状态图中只能有一个初态，而终态则可以有0至多个</li></ul> <h4 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h4> <ul><li>事件是在某个特定时刻发生的事情，它是对引起系统做状态或（和）从一个状态转换到另一个状态的外界条件的抽象</li> <li>例如：内部时钟表明某个规定的时间段已经过去，用户移动或点击鼠标等都是事件</li> <li>简而言之，<font color="red">事件就是引起系统做动作或（和）转换状态的控制信息</font></li></ul> <h4 id="图形符号"><a href="#图形符号" class="header-anchor">#</a> 图形符号</h4> <ul><li><font color="red">初态</font>用<font color="red">实心圆</font>表示，<font color="red">终态</font>用<font color="red">一对同心圆（内圆为实心圆）</font>表示。</li> <li><font color="red">中间态</font>用<font color="red">圆角矩形</font>表示，可以用<font color="red">两条水平横线</font>把它分成上、中、下3个部分。<font color="red">上面部分</font>为<font color="red">状态的名称</font>，这部分是<font color="red">必须有的</font>；<font color="red">中间部分</font>为<font color="red">状态变量的名字和值</font>，这部分是<font color="red">可选的</font>；<font color="red">下面部分</font>是<font color="red">活动表</font>，这部分也是<font color="red">可选的</font>。
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306131725655.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306131856361.png" alt="image.png"></li></ul> <h2 id="作业3"><a href="#作业3" class="header-anchor">#</a> 作业3</h2> <blockquote><ol><li>数据字典是软件需求分析阶段的最重要的工具之一，其最基本的功能是（数据定义）</li> <li>结构分析方法就是面向（数据流）的自顶向下逐步求精进行需求分析的方法</li> <li>为了提高软件质量，确保软件开发成功，必须严格验证软件需求。一般来说，验证软件需求应考虑的因素有（一致性、完整性、现实性和有效性）</li> <li>数据字典是用来定义（数据流图）中各个成分的具体含义的</li> <li>进行需求分析可使用多种工具，但（N-S图）是不适用的</li> <li>用户提出“系统在200人同时使用时，操作响应时间不能超过0.5秒”，这属于（性能需求）</li> <li>结构化分析方法是一种预先严格定义需求的方法，它在实施时强调的是分析系统的（数据流）</li> <li>需求分析中，开发人员要从用户那里了解（软件做什么）</li> <li>需求分析是保证软件质量的重要步骤，它的实施应该是在（软件定义阶段）</li> <li>画某系统的数据流图时，顶层图有（1张）</li> <li>通过（功能分解）可以完成数据流图的细化</li> <li>在数据流图中，椭圆代表（加工）</li> <li>软件需求规格说明的内容不应包括（算法的详细描述）</li> <li>以下关于数据流图的说法错误的是（传统的数据流图中主要由加工、数据源点/终点、数据流、控制流、数据存储组成），解释：传统的数据流图中主要由加工、数据源点/终点、数据流、数据存储组成，不包括控制流</li> <li>数据流图和（数据字典）共同组成系统的逻辑模型</li> <li>数据流图是一种描述数据及其变换的图形表示，在数据流图上不允许出现（控制流）</li> <li>在E-R模型中，包括以下基本成分（实体、联系、属性）</li> <li>需求规格说明书的作用不应该包括（软件可行性研究的依据）</li> <li>用户提出系统在一个月内不能出现2次以上的故障，这属于（可靠性需求）</li> <li>软件需求分析阶段的工作，可以分为四个方面：对问题的识别、分析与综合、编写需求分析文档以及（需求分析评审）</li> <li>在需求分析中，开发人员要从用户那里解决的最重要的问题是（要让软件做什么）</li> <li>DFD中的“→”代表（数据流）</li> <li>在一个列车控制软件的需求文档中，我们发现了以下两条需求描述：“列车车门在两个停靠站之间要保持关闭”；“列车发生紧急停车时，要打开车门”。这里出现的需求问题是什么？答：矛盾与不一致的需求</li></ol></blockquote> <h1 id="软件设计"><a href="#软件设计" class="header-anchor">#</a> 软件设计</h1> <h2 id="软件设计概念"><a href="#软件设计概念" class="header-anchor">#</a> 软件设计概念</h2> <h3 id="什么是软件设计"><a href="#什么是软件设计" class="header-anchor">#</a> 什么是软件设计?</h3> <ul><li>软件的设计是将需求转变为软件陈述（表达）的过程。这种陈述是一个对软件的全局观点。系统通过逐步求精使得设计陈述逐渐接近程序代码。
<ul><li><strong>第一步是概要设计，关注于怎么将需求转换成数据和软件框架</strong></li> <li><strong>第二步详细设计，关注于将框架逐步求精细化为具体的数据结构和算法表达</strong></li></ul></li></ul> <h3 id="设计"><a href="#设计" class="header-anchor">#</a> 设计</h3> <p>“软件设计宣言”：设计良好的软件应该展示出：</p> <ul><li><em>坚固性</em>：程序应该不含任何妨碍其功能的缺陷</li> <li><em>通用性</em>：程序应该符合开发的目标</li> <li><em>愉悦性</em>：使用程序的体验应该是愉悦的</li></ul> <h3 id="良好设计应具备的特征"><a href="#良好设计应具备的特征" class="header-anchor">#</a> 良好设计应具备的特征</h3> <ul><li><font color="red">设计必须实现所有包含在需求模型中的明确需求</font>，而且必须满足利益相关者期望的所有隐含需求</li> <li>对于编码、测试及维护而言，<font color="red">设计必须是可读的、可理解的指南</font></li> <li><font color="red">设计必须提供软件的全貌</font>，从实现的角度说明数据域、功能域和行为域</li></ul> <h3 id="设计质量指导原则"><a href="#设计质量指导原则" class="header-anchor">#</a> 设计质量指导原则</h3> <ul><li>设计应展示出这样一种结构：<font color="red">（1）已经使用可识别的体系结构风格或模式创建；（2）由展现出良好设计特征的构件构成；（3）能够以演化的方式实现，从而便于实现和测试</font></li> <li><font color="red">设计应该模块化；</font>也就是说，应将软件逻辑地划分为元素或子系统</li> <li><font color="red">设计应该包含数据、体系结构、接口和构件的清晰表示</font></li> <li><font color="red">设计应导出数据结构</font>，这些数据结构适用于要实现的类，并从可识别的数据模式提取</li> <li><font color="red">设计应导出显示独立功能特征的构件</font></li> <li><font color="red">设计应导出接口</font>，这些接口降低了构件之间以及与外部环境连接的复杂性</li> <li><font color="red">设计的导出应根据软件需求分析过程</font>中获取的信息采用可重复的方法进行</li> <li><font color="red">设计应使用能够有效的表示法来传达其意义</font></li></ul> <h3 id="设计概念"><a href="#设计概念" class="header-anchor">#</a> 设计概念</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132019590.png" alt="image.png"></p> <h4 id="设计概念-抽象"><a href="#设计概念-抽象" class="header-anchor">#</a> 设计概念——抽象</h4> <ul><li>是人类处理问题的基本方法</li> <li>抽出事物的本质特性而暂时不考虑细节，可以给出不同的抽象级。</li> <li>两种不同的抽象：<font color="red">数据抽象、过程抽象</font></li></ul> <h5 id="数据抽象"><a href="#数据抽象" class="header-anchor">#</a> 数据抽象</h5> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132022195.png" alt="image.png"></p> <h5 id="过程抽象"><a href="#过程抽象" class="header-anchor">#</a> 过程抽象</h5> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132023189.png" alt="image.png"></p> <h3 id="体系结构"><a href="#体系结构" class="header-anchor">#</a> 体系结构</h3> <ul><li>软件体系结构是指“软件的整体结构和这种结构为系统提供概念上完整性的方式”</li> <li>结构模型：将体系结构表示为程序构件的一个有组织的集合</li> <li>框架模型：提高设计抽象级别</li> <li>动态模型：强调程序体系结构的行为方面</li> <li>过程模型：系统必须提供的业务设计或技术流程设计</li> <li>功能模型：表示系统的功能层次结构</li></ul> <h3 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h3> <p><font color="red">设计模式</font>是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的</p> <h3 id="关注点分离"><a href="#关注点分离" class="header-anchor">#</a> 关注点分离</h3> <ul><li><font color="red">关注点分离</font>是日常生活和生产中广泛使用的解决复杂问题的一种系统思维方法</li> <li>大体思路是,先将复杂问题做合理的分解,再分别仔细研究问题的不同侧面(<font color="red">关注点</font>),最后综合各方面的结果,合成整体的解决方案。如果被分解为可以独立解决和（或）优化的若干块，任何复杂问题都能够更容易地被处理。</li> <li>通过将关注点分割为更小的关注点（由此产生更多可管理的块），使得解决一个问题需要付出更少的工作量和时间</li></ul> <h3 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h3> <ul><li>几乎所有的情况下，为了理解更容易，都应当将设计划分成许多模块，这样做的结果，构建软件所需的成本将会随之降低。</li> <li><strong>按照设计原则将系统划分成若干个较小的模块</strong> <ul><li><font color="red">相互独立但又相互关联</font></li> <li><font color="red">实际上是系统分解和抽象的过程</font></li></ul></li> <li><strong>模块是相对独立的程序体</strong> <ul><li><font color="red">是数据说明、可执行语句等程序对象的集合</font></li> <li><font color="red">单独命名的，并且可以通过名字来访问</font> <ul><li>例如：类、过程、函数、子程序、宏等</li></ul></li></ul></li></ul> <h3 id="通过模块化降低开发复杂度"><a href="#通过模块化降低开发复杂度" class="header-anchor">#</a> 通过模块化降低开发复杂度</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132038424.png" alt="image.png"></p> <h3 id="无限制地进行模块化分"><a href="#无限制地进行模块化分" class="header-anchor">#</a> 无限制地进行模块化分？</h3> <p><strong>结论：No</strong></p> <ul><li>模块数量增加时，只是使各个子模块的工作量之和有所减少</li> <li>然而开发工作量还有很大一部分来自于模块间的接口和集成</li> <li>除了技术上的接口和集成，还包括<font color="red">人与人之间的沟通，集成和沟通的开销到了一定程度就会成为开发工作量的主要部分</font></li></ul> <p><strong>结论：适度的模块化</strong></p> <ul><li><strong>模块数量增加时，模块间的关系也随之增加，接口和集成的工作量也随之增加</strong></li> <li><font color="red">寻找最佳模块化程度平衡点</font></li></ul> <h3 id="信息隐蔽"><a href="#信息隐蔽" class="header-anchor">#</a> 信息隐蔽</h3> <ul><li><strong>每个模块都尽量对其他模块隐藏自己的内部实现细节</strong> <ul><li><strong>模块内部的数据和过程不允许其他不需要这些信息的模块使用</strong></li> <li><strong>定义和实施对模块的过程细节和局部数据结构的存取限制</strong></li> <li><font color="red">典型的信息隐藏：面向对象的访问控制符</font></li></ul></li> <li><strong>信息隐藏是实现抽象/模块化机制的基本支撑</strong></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132048877.png" alt="image.png"></p> <h3 id="为什么隐蔽信息"><a href="#为什么隐蔽信息" class="header-anchor">#</a> 为什么隐蔽信息？</h3> <ul><li>降低“副作用”的可能性</li> <li>减少局部设计决定对全局的影响</li> <li>突出控制接口处通信</li> <li>阻止全局数据使用</li> <li>促进封装——高质量设计的属性之一</li> <li>形成高质量软件</li></ul> <h3 id="功能独立"><a href="#功能独立" class="header-anchor">#</a> 功能独立</h3> <ul><li>通过开发具有“专一”功能和“避免”与其他模块过多交互的模块，可以实现功能独立</li> <li><em>内聚性</em>显示了某个模块相关功能的强度
<ul><li>一个内聚的模块执行一个独立的任务，与程序的其他部分构件只需要很少的交互。简单的说，一个内聚的模块应该只完成一件事情</li></ul></li> <li><em>耦合性</em>显示了模块间的相互依赖性
<ul><li>耦合性依赖于模块之间的接口复杂性、引用或进入模块所在的点以及什么数据通过接口进行传递</li></ul></li></ul> <h3 id="方面"><a href="#方面" class="header-anchor">#</a> 方面</h3> <p>考虑两个需求，A和B。“如果已经选择了一种软件分解[精化]，在这种分解中，如果不考虑需求A的话，需求B就不能得到满足” ，那么需求A横切需求B、</p> <h3 id="重构"><a href="#重构" class="header-anchor">#</a> 重构</h3> <p>“重构是使用这样一种方式改变软件系统的过程：不改变代码[设计]的外部行为而是改进其内部结构。”</p> <p>当重构软件时，检查现有设计的：</p> <ul><li>冗余性</li> <li>没有使用的设计元素</li> <li>低效的不必要的算法</li> <li>拙劣的或不恰当的数据结构</li> <li>以及其他不足，并通过修改获得更好的设计</li></ul> <h3 id="面向对象的设计概念"><a href="#面向对象的设计概念" class="header-anchor">#</a> 面向对象的设计概念</h3> <ul><li>设计类
<ul><li>实体类</li> <li>控制类</li> <li>边界类</li></ul></li> <li>继承——超类的属性的任何改变都可以立即被所有子类继承</li> <li>消息——刺激接收对象产生的某种行为</li> <li>多态——这种特征可显著减少扩展已存在的设计所需的工作量</li></ul> <h3 id="设计任务"><a href="#设计任务" class="header-anchor">#</a> 设计任务</h3> <ul><li>数据/类设计——将分析类模型转换为软件实现类模型及数据结构</li> <li>体系结构设计——描述软件主要构造元素之间的关系</li> <li>接口设计——描述软件元素、硬件元素和终端用户间如何通信</li> <li>构建级设计——将软件体系结构的构造元素变换为对软件构件的过程性描述</li></ul> <h4 id="数据-类设计"><a href="#数据-类设计" class="header-anchor">#</a> 数据/类设计</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132129359.png" alt="image.png"></p> <h4 id="体系结构设计"><a href="#体系结构设计" class="header-anchor">#</a> 体系结构设计</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132130272.png" alt="image.png"></p> <h4 id="接口设计"><a href="#接口设计" class="header-anchor">#</a> 接口设计</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132131691.png" alt="image.png"></p> <h4 id="构件级设计"><a href="#构件级设计" class="header-anchor">#</a> 构件级设计</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132132139.png" alt="image.png"></p> <h2 id="体系结构风格"><a href="#体系结构风格" class="header-anchor">#</a> 体系结构风格</h2> <ul><li>每一种风格描述一种系统类别，，包括：
<ul><li>一组<em>构件</em>，它们完成某种功能</li> <li>一组<em>连接器</em>，它们实现构件间的“通信、合作和协调”</li> <li><em>约束</em>，定义构件如何集成为一个系统</li> <li><em>语义模型</em>，使设计者能通过分析系统的构成，来理解系统的整体性质</li></ul></li> <li>以数据为中心的体系结构</li> <li>数据流体系结构</li> <li>调用和返回体系结构</li> <li>层次体系结构</li></ul> <h3 id="以数据为中心的体系结构"><a href="#以数据为中心的体系结构" class="header-anchor">#</a> 以数据为中心的体系结构</h3> <p><em>数据存储</em>驻留在体系结构的<em>中心</em>，其他构件访问该数据存储，并进行各种数据操作
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132138395.png" alt="image.png"></p> <h3 id="数据流体系结构"><a href="#数据流体系结构" class="header-anchor">#</a> 数据流体系结构</h3> <p>也称<em>管道/过滤器</em>结构
拥有一组称为<em>过滤器</em>的构建，这些构建通过<em>管道</em>连接，每个过滤器<em>独立</em>于其上游和下游的构建而工作
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132143967.png" alt="image.png"></p> <h3 id="调用和返回体系结构"><a href="#调用和返回体系结构" class="header-anchor">#</a> 调用和返回体系结构</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132146594.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132147945.png" alt="image.png"></p> <h3 id="层次体系结构"><a href="#层次体系结构" class="header-anchor">#</a> 层次体系结构</h3> <ul><li>定义了不同的层次，各个层次完成各自操作</li> <li>每一层为上层提供服务，又接受下层的服务
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132148028.png" alt="image.png"></li></ul> <h2 id="体系结构设计-2"><a href="#体系结构设计-2" class="header-anchor">#</a> 体系结构设计</h2> <ul><li><em>结构化设计</em> <ul><li>数据流模型 --&gt; 软件结构图</li></ul></li> <li>面向对象设计
<ul><li>用例模型 --&gt; 分析类图 --&gt; 设计类图 --&gt; 构件图</li></ul></li></ul> <h3 id="构建化设计"><a href="#构建化设计" class="header-anchor">#</a> 构建化设计</h3> <ul><li>结构化设计是将结构化分析的结果（数据流图）映射成软件的体系结构（结构图）</li> <li>根据信息流的特点，可将数据流图分为变换型数据流图和事物型数据流图，其对应的映射分别称为<em>变换分析</em>和<em>事务分析</em></li></ul> <h3 id="数据流图映射到结构图的步骤"><a href="#数据流图映射到结构图的步骤" class="header-anchor">#</a> 数据流图映射到结构图的步骤</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132154109.png" alt="image.png"></p> <h4 id="变换分析"><a href="#变换分析" class="header-anchor">#</a> 变换分析</h4> <ol><li><em>划定输入流和输出流的边界，确定变换中心</em></li></ol> <ul><li>概念
<ul><li><em>物理输入</em>：系统输入端的数据流</li> <li><em>物理输出</em>：系统输出端的数据流</li> <li><em>逻辑输入</em>：变换中心的输入数据流</li> <li><em>逻辑输出</em>：变换中心的输出数据流</li></ul></li> <li>物理输入要经过编辑、格式转换、合法性检查等辅助性加工后变成纯粹的逻辑输入再传给变换中心；变换中心产生的逻辑输出要经过格式转换、组成物理块、缓冲处理等辅助性加工后变成物理输出，再送到系统外</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132200045.png" alt="image.png"></p> <h4 id="进行第一级分解"><a href="#进行第一级分解" class="header-anchor">#</a> 进行第一级分解</h4> <p>第一级分解是将DFD映射成变换型的程序结构</p> <ul><li>主控模块：完成整个系统的功能</li> <li>输入流控制模块：接收所有输入数据</li> <li>变换流控制模块：对内部形式的数据进行加工处理，实现输入到输出的变换</li> <li>输出流控制模块：产生所有输出数据</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306132222033.png" alt="image.png"></p> <h4 id="进行第二级分解"><a href="#进行第二级分解" class="header-anchor">#</a> 进行第二级分解</h4> <ul><li>输入流控制模块的分解：
<ul><li>从变换中心的边界开始，沿着输入通路向外移动，把输入通路上的每个加工映射成程序结构中输入流控制模块的一个低层模块</li></ul></li> <li>输出流控制模块的分解：
<ul><li>从变换中心的边界开始，沿着输出通路向外移动，把输出通路上的每个加工映射成程序结构中输出控制流模块的一个低层模块</li></ul></li> <li>变换流控制模块的分解
<ul><li>把变换中心的每个加工映射成受变换控制模块控制的一个低层模块</li></ul></li></ul> <h2 id="构件级设计-2"><a href="#构件级设计-2" class="header-anchor">#</a> 构件级设计</h2> <h3 id="理解构件设计"><a href="#理解构件设计" class="header-anchor">#</a> 理解构件设计</h3> <ul><li><em>体系设计</em>——建筑平面图、结构、房间和外部环境之间的连接机制</li> <li><em>构件级设计</em>——每个房间的内部细节设计</li></ul> <h3 id="什么是构件"><a href="#什么是构件" class="header-anchor">#</a> 什么是构件</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230614112509.png" alt="image.png"></p> <h4 id="传统构件"><a href="#传统构件" class="header-anchor">#</a> 传统构件</h4> <p>传统构件也称为模块，作为软件体系结构的一部分，它承担如下3个重要角色之一：</p> <ul><li><em>控制构件</em>，协调问题域中所有其他构件的调用</li> <li><em>问题域构件</em>，实现客户需要的全部功能或部分功能</li> <li><em>基础设施构件</em>，负责完成问题域中所需支持处理的功能</li></ul> <h3 id="基本设计原则"><a href="#基本设计原则" class="header-anchor">#</a> 基本设计原则</h3> <ul><li>开闭原则（OCP）：模块[构件]应该对外延具有开放性，对修改具有封闭性</li> <li>Liskov替换原则：子类可以替换它们的基类</li> <li>依赖倒置原则：依赖于抽象，而非具体实现</li> <li>接口分离原则：多个客户专用接口比一个通用接口要好</li> <li>发布复用等价原则：复用的粒度就是发布的粒度</li> <li>共同封装原则：一同变更的类应该合在一起</li> <li>共同复用原则：不能一起复用的类不能被分到一组</li></ul> <h3 id="内聚性"><a href="#内聚性" class="header-anchor">#</a> 内聚性</h3> <ul><li><em>内聚</em>是从功能的角度对模块内部聚合能力的量度。高内聚是模块独立性追求的目标</li> <li>传统观点：
<ul><li>构件的专一性</li></ul></li> <li>面向对象的观点：
<ul><li>内聚性意味着构件或类只封装那些互相关联密切，以及与构件或类自身有密切关系的属性和操作
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141226490.png" alt="image.png"></li></ul></li></ul> <h3 id="耦合性"><a href="#耦合性" class="header-anchor">#</a> 耦合性</h3> <ul><li><em>耦合性</em>是对一个软件结构内不同模块之间互连程度的度量。耦合性的强弱取决于模块间接口的复杂程度，以及通过接口的数据类型和数目</li> <li>传统观点：
<ul><li>一个组件连接到其他组件和外部世界的程度</li></ul></li> <li>面向对象的观点：
<ul><li>类之间彼此联系程序的一种定性度量
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141228233.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141229348.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141230844.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141231055.png" alt="image.png"></li></ul></li></ul> <h3 id="设计传统构件"><a href="#设计传统构件" class="header-anchor">#</a> 设计传统构件</h3> <ul><li>主要任务
<ul><li>设计每个模块的详细算法</li> <li>设计每个模块内的数据结构</li></ul></li> <li>结构化程序设计方法
<ul><li>采用自顶向下、逐步求精及模块化的程序设计方法；使用三种基本控制结构（顺序、选择、循环）构造程序</li></ul></li> <li>结构化程序设计方法特点
<ul><li>以控制结构为单位，，单入口单出口</li> <li>从上到下顺序地阅读程序文本</li> <li>由于程序的静态描述与执行时的控制流程容易对应，所以能够方便地理解程序</li></ul></li></ul> <h3 id="处理逻辑的表示工具"><a href="#处理逻辑的表示工具" class="header-anchor">#</a> 处理逻辑的表示工具</h3> <ul><li><em>活动图、流程图</em></li> <li>NS图</li> <li>PAD图</li> <li>判定表、判定树</li> <li>过程设计语言PDL</li></ul> <h4 id="活动图-2"><a href="#活动图-2" class="header-anchor">#</a> 活动图</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141238361.png" alt="image.png"></p> <h4 id="流程图、ns图、pad图"><a href="#流程图、ns图、pad图" class="header-anchor">#</a> 流程图、NS图、PAD图</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141239129.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141239299.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141239167.png" alt="image.png"></p> <h4 id="判定表"><a href="#判定表" class="header-anchor">#</a> 判定表</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141239206.png" alt="image.png"></p> <h4 id="判定树"><a href="#判定树" class="header-anchor">#</a> 判定树</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141240788.png" alt="image.png"></p> <h4 id="pdl"><a href="#pdl" class="header-anchor">#</a> PDL</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141241704.png" alt="image.png"></p> <h2 id="用户界面设计"><a href="#用户界面设计" class="header-anchor">#</a> 用户界面设计</h2> <h3 id="界面设计"><a href="#界面设计" class="header-anchor">#</a> 界面设计</h3> <p>典型的设计错误有：</p> <ul><li>缺乏一致性</li> <li>记忆负担过重</li> <li>没有向导或帮助</li> <li>语境不敏感</li> <li>反馈不好</li> <li>晦涩难解/不友好</li></ul> <h3 id="黄金规则"><a href="#黄金规则" class="header-anchor">#</a> 黄金规则</h3> <ul><li><em>把控制权交给用户</em></li> <li><em>减少用户的记忆负担</em></li> <li><em>保持界面一致</em></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141244452.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141245990.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141245363.png" alt="image.png"></p> <h3 id="任务分析和建模"><a href="#任务分析和建模" class="header-anchor">#</a> 任务分析和建模</h3> <ul><li><em>用例</em>定义基本交互方式</li> <li><em>任务细化</em>细化交互任务</li> <li><em>对象细化</em>标识界面对象（类）</li> <li><em>工作流分析</em>定义了当涉及多个成员（角色）时，工作过程是如何完成的</li></ul> <h1 id="软件测试"><a href="#软件测试" class="header-anchor">#</a> 软件测试</h1> <h2 id="基本概念-2"><a href="#基本概念-2" class="header-anchor">#</a> 基本概念</h2> <h3 id="什么是软件测试"><a href="#什么是软件测试" class="header-anchor">#</a> 什么是软件测试</h3> <ul><li>狭义：为了发现软件错误而执行软件的过程。</li> <li>广义：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</li> <li>测试是为了证明程序中有错误，而不是证明程序中无错误</li> <li>一个好的测试用例指的是它可能发现至今尚未发现的缺陷</li> <li>一次成功的测试指的是发现了新的软件缺陷的测试</li></ul> <h3 id="有关软件测试的错误观点"><a href="#有关软件测试的错误观点" class="header-anchor">#</a> 有关软件测试的错误观点</h3> <ul><li>“软件测试是为了证明程序是正确的，即测试能发现程序中所有的错误”</li> <li>要通过测试发现程序中的所有错误，就要穷举所有可能的输入数据.这是不可能的</li></ul> <h3 id="软件测试原则"><a href="#软件测试原则" class="header-anchor">#</a> 软件测试原则</h3> <ul><li>足够好原则
<ul><li>不充分的测试是不负责任的</li> <li>过分的测试是一种资源的浪费</li> <li>制定最低测试通过标准和测试内容</li></ul></li> <li>Pareto法则（80/20定律）
<ul><li>测试中发现的80%的错误可能来自于20%的程序代码</li> <li>充分注意测试中的群集现象。经验表明，测试后程序残存的错误数目与该程序中已发现的错误数目成正比</li></ul></li> <li>应该“尽早和不断地进行软件测试”</li> <li>测试计划在需求分析阶段,测试用例设计在设计阶段</li> <li>穷举测试是不可能的</li> <li>应当避免由程序员检查自己的程序。（指后期系统测试阶段，不包括单元测试）</li> <li>在设计测试用例时，应包括合理的输入条件和不合理的输入条件</li> <li>严格执行测试计划，排除测试的随意性</li> <li>应当对每一个测试结果做全面检查</li> <li>妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便</li></ul> <h3 id="测试用例"><a href="#测试用例" class="header-anchor">#</a> 测试用例</h3> <p><em>测试用例</em>是指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档</p> <h3 id="测试用例设计"><a href="#测试用例设计" class="header-anchor">#</a> 测试用例设计</h3> <ul><li>测试用例的设计是软件测试的关键所在</li> <li>设计尽可能少的测试用例来发现尽可能多的错误</li> <li>设计最有可能发现软件错误的测试用例同时避免使用发现错误效果相同的测试用例</li> <li>测试用例的设计方法大体分为两类：<em>白盒测试</em>和<em>黑盒测试</em>，也称白箱测试和黑箱测试</li></ul> <p><em>白盒测试</em>（又称为结构测试）把测试对象看作一个透明的盒子，测试人员根据程序内部的逻辑结构及有关信息设计测试用例，检查程序中所有逻辑路径是否都按预定的要求正确地工作，<em>白盒测试主要用于对模块的测试</em></p> <p><em>黑盒测试</em>（又称为行为测试）把测试对象看作一个黑盒子，测试人员完全<em>不考虑程序内部的逻辑结构和内部特性</em>，<em>只依据程序的需求规格说明书</em>，检查程序的功能是否符合它的功能需求，<em>黑盒测试可用于各种测试</em></p> <h2 id="软件测试的分类"><a href="#软件测试的分类" class="header-anchor">#</a> 软件测试的分类</h2> <h3 id="按测试方式分类"><a href="#按测试方式分类" class="header-anchor">#</a> 按测试方式分类</h3> <ul><li>静态测试（不需要执行所测试的程序，查询代码是否符合规范，对程序的数据流和控制流进行分析）</li> <li>动态测试（选择实际测试用例运行测试程序，模拟用户输入）</li></ul> <h3 id="按测试过程分类"><a href="#按测试过程分类" class="header-anchor">#</a> 按测试过程分类</h3> <ul><li><em>单元测试</em>：是针对程序中的<em>模块或构件</em>，主要揭露<em>编码阶段</em>产生的错误</li> <li><em>集成测试</em>：针对<em>集成的软件系统</em>，主要揭露<em>设计阶段</em>产生的错误</li> <li><em>确认测试</em>：是<em>根据软件需求规约</em>对<em>集成的软件</em>进行确认，主要揭露<em>不符合需求规约</em>的错误</li> <li><em>系统测试</em>：对于<em>基于计算机系统中的软件</em>，还需要将它集成到基于计算机系统中，并进行<em>系统测试</em>，以揭露<em>不符合系统工程中对软件要求</em>的错误</li></ul> <h3 id="按测试目的分类"><a href="#按测试目的分类" class="header-anchor">#</a> 按测试目的分类</h3> <ul><li>功能测试，健壮性测试，接口测试，性能测试，强度测试，压力测试，用户界面测试，安全测试，可靠性测试，安装/反安装测试，文档测试，恢复测试，兼容性测试</li></ul> <h2 id="测试策略"><a href="#测试策略" class="header-anchor">#</a> 测试策略</h2> <h3 id="软件测试的组织"><a href="#软件测试的组织" class="header-anchor">#</a> 软件测试的组织</h3> <ul><li>应由什么人来组织测试：
<ul><li>测试贯穿于整个软件的开发过程中，开发人员必须参与测试</li> <li>对即将交付软件的集成测试，开发人员往往也要参加</li> <li>集成测试中，有独立测试组（ITG）的介入</li> <li>ITG应从一开始就要介入项目，只是不像开发人员过多地注意细节</li></ul></li></ul> <h3 id="测试完成的标准"><a href="#测试完成的标准" class="header-anchor">#</a> 测试完成的标准</h3> <ul><li>测试只能是在某个阶段告一段落。</li> <li>由于软件使用的软环境可能要永恒地变化。所以，它时刻、永远地面临考验，没有尽头。</li> <li>测试是永远也完不成的。</li></ul> <h3 id="测试策略-2"><a href="#测试策略-2" class="header-anchor">#</a> 测试策略</h3> <ul><li>开始于<em>小范围测试</em>，并移向<em>大范围测试</em></li> <li>对于传统的软件
<ul><li>开始集中在模块（构件）</li> <li>之后进行模块集成</li></ul></li> <li>对于面向对象的软件
<ul><li>当进行<em>小范围测试</em>时，关注点从单个模块（传统上的）转变到面向对象的类，类封装了属性和操作，并意味着通信和协作</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141331784.png" alt="image.png"></p> <h3 id="单元测试"><a href="#单元测试" class="header-anchor">#</a> 单元测试</h3> <p>什么是单元测试</p> <ul><li>指对软件中的<em>最小可测试单元</em>进行检查和验证。单元，一般应根据实际情况判定其具体含义，如C语言中，单元指一个函数，Java中，单元指一个类，图形化软件中也可以是一个窗口、一个菜单等，单元就是认为规定的最小被测试的模块</li></ul> <h4 id="何时进行单元测试"><a href="#何时进行单元测试" class="header-anchor">#</a> 何时进行单元测试</h4> <ul><li>时机
<ul><li>通常在编码完成后进行，在前期应准备，如写单元测试计划，编单元测试用例、单元测试代码等。开发人员完成</li></ul></li> <li>单元测试的依据
<ul><li>源程序中，项目的《详细设计》文档</li></ul></li> <li>如何进行单元测试
<ul><li>一般先<em>静态</em>地检查代码是否符合规范，然后<em>动态</em>地运行代码并检查运行结果</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141340876.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141342230.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141342380.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141343245.png" alt="image.png"></p> <h3 id="集成测试"><a href="#集成测试" class="header-anchor">#</a> 集成测试</h3> <ul><li>集成测试是通过发现和接口有关的问题来构造程序结构的系统化技术，其目标是把通过了单元测试的模块拿来，构造一个设计中所描述的程序结构</li> <li><em>一步到位</em>的集成</li> <li><em>增量集成</em>：程序以<em>小增量</em>方式进行构造和测试
<ul><li><em>自顶向下测试</em>：从主控模块开始，沿着控制层次模块逐步向下，利用深度优先或广度优先的方式将从属于主控模块的模块集成到结构中去</li> <li><em>自底向上测试</em>：从原子模块开始进行构造和测试</li> <li><em>组合方法（三明治）</em>：用自顶向下方法测试程序结构较高层，用自底向上方法测试其从属层</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141348197.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141349858.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141350667.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141350705.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141351336.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141351572.png" alt="image.png"></p> <h3 id="回归测试"><a href="#回归测试" class="header-anchor">#</a> 回归测试</h3> <ul><li><em>回归测试</em>是重新运行已经进行过的测试子集，以确保变更没有引发非预期的副作用</li> <li>每次对软件进行修改时，就改变了软件配置的某些方面（软件、文档及支持软件的数据）</li> <li>回归测试有助于确保变更（由于测试或其他原因）不会引入非预期的行为或者增加的错误</li> <li>回归测试可以手动进行，通过重新运行一部分测试用例或全部测试用例，也可以使用自动的捕获/回放工具</li></ul> <h3 id="冒烟测试"><a href="#冒烟测试" class="header-anchor">#</a> 冒烟测试</h3> <ul><li>这一术语源自硬件行业。对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。</li> <li>是指在对一个新版系统进行大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测试性。</li> <li>是对产品软件进行“每日构造”的一种常见方法。</li></ul> <p>冒烟测试步骤:</p> <ul><li>将已经转换为代码的软件构件集成到构造（ “build” ）中。
<ul><li>一个构造包括所有的数据文件、库、可重用的模块、以及工程化的构件，其中一个构件需要实现一项或多项产品功能。</li></ul></li> <li>设计一系列测试来揭示错误，使得此构造不能正确地执行其功能。
<ul><li>目的是揭示“显示阻塞” 错误，这种错误最有可能使软件项目滞后于进度计划。</li></ul></li> <li>将此构造与其他构造集成在一起，每天都对整个产品（以其当前的形式）进行冒烟测试。
<ul><li>集成方法可以是自顶向下，也可以是自底向上。</li></ul></li></ul> <h3 id="面向对象软件的测试"><a href="#面向对象软件的测试" class="header-anchor">#</a> 面向对象软件的测试</h3> <p>类测试</p> <ul><li>不再孤立的测试单个操作，而是将其作为类的一部分，相当于传统软件的单元测试</li> <li>要考虑类的层次，测试顺序由父类到子类</li></ul> <p>集成测试</p> <ul><li>基于线程的测试</li> <li>基于使用的测试</li></ul> <h3 id="确认测试"><a href="#确认测试" class="header-anchor">#</a> 确认测试</h3> <ul><li>侧重于需求级的错误，即对最终用户是显而易见的错误</li> <li>软件规格说明中包含的信息是确认测试的基础
配置评审：确保所有软件配置元素已正确开发、编码，且具有软件生命周期各阶段的必要细节</li> <li>α测试：最终用户在开发场所完成，软件在自然的环境下使用，开发者在旁边观看，并记录错误和使用问题</li> <li>β测试：在最终用户场所执行，开发者通常不在场</li></ul> <h3 id="系统测试"><a href="#系统测试" class="header-anchor">#</a> 系统测试</h3> <p>系统测试是将已经继承好的软件系统，作为计算机系统的一个元素，与计算机硬件、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行一系列的集成测试和确认测试。</p> <ul><li>恢复测试
<ul><li>通过各种方式强制地让系统发生故障，并验证其能适当恢复</li></ul></li> <li>安全测试
<ul><li>验证系统内的保护机制能够保护系统不受非法入侵</li> <li>使攻破系统所付出的代价大于攻破系统之后获取信息的价值</li></ul></li> <li>压力测试
<ul><li>能将系统折腾到什么程度而不会出错？</li> <li>以一种反常数量、频率或容量的方式执行系统</li></ul></li> <li>性能测试
<ul><li>测试软件的运行性能</li> <li>常和压力测试一起进行，常需要硬件和软件配合</li></ul></li></ul> <h2 id="测试方法"><a href="#测试方法" class="header-anchor">#</a> 测试方法</h2> <h3 id="白盒测试技术"><a href="#白盒测试技术" class="header-anchor">#</a> 白盒测试技术</h3> <ul><li>白盒测试是有选择地执行（或覆盖）程序中某些最有代表性路径的测试方法，所以也称为<em>逻辑覆盖测试</em> <ul><li><em>逻辑覆盖法</em></li> <li><em>基本路径测试法</em></li> <li><em>循环测试方法</em></li></ul></li></ul> <h4 id="逻辑覆盖法"><a href="#逻辑覆盖法" class="header-anchor">#</a> 逻辑覆盖法</h4> <p><span style="color:#ff0000;">语句覆盖</span>：选择足够的测试用例，使得程序中每个语句至少都能被执行一次
<span style="color:#ff0000;">判定覆盖</span>：执行足够的测试用例，使得程序中没个判定至少获得一次“真”值和“假值”，即使得程序中每一个分支至少都通过一次
<span style="color:#ff0000;">条件覆盖</span>：执行足够的测试用例，使得判定中每个条件获得各种可能的结果
<span style="color:#ff0000;">判定/条件覆盖</span>：执行足够的测试用例，同时满足判定覆盖和条件覆盖的要求
<span style="color:#ff0000;">条件组合覆盖</span>：执行足够的测试用例，使得每个判断中条件的各种可能组合都要至少执行一次</p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141456746.png" alt="image.png"></p> <p><mark style="background:#ABF7F7A6;">语句覆盖</mark></p> <ul><li>路径ace，选择输入数据为：A = 2，B = 0， x = 3</li></ul> <p><mark style="background:#ABF7F7A6;">判定覆盖</mark></p> <ul><li>路径acd执行，选择输入数据为：A = 3，B = 0，x = 1</li> <li>路径abe执行，选择输入数据为：A = 2，B = 1, x = 3</li></ul> <p><mark style="background:#ABF7F7A6;">条件覆盖</mark></p> <ul><li>沿路径ace执行，选择输入为：A＝2，B＝0，x＝4</li> <li>沿路径abd执行，选择输入为：A＝1，B＝1，x＝1</li></ul> <p><mark style="background:#ABF7F7A6;">判定/条件覆盖</mark></p> <ul><li>沿路径ace执行，选择输入为：A=2，B=0，x=4</li> <li>沿路径abd执行，选择输入为：A＝1，B＝1，x＝1</li></ul> <p><mark style="background:#ABF7F7A6;">条件组和覆盖</mark> <span style="color:#ff0000;">八种组合结果</span>
(1)A&gt;1，B=0   (5)A=2，x&gt;1
(2)A&gt;1，B&lt;&gt;0  (6)A=2，x&lt;1
(3)A&lt;1，B=0   (7)A&lt;&gt;2，x&gt;1
(4)A&lt;1，B&lt;&gt;0  (8)A&lt;&gt;2，x&lt;1</p> <p><span style="color:#ff0000;">四种测试用例来覆盖</span>
(1)A＝2，B＝0，x＝4 覆盖(1)(5)
(2)A＝2，B＝1，x＝1 覆盖(2)(6)
(3)A＝1，B＝0，x＝2 覆盖(3)(7)
(4)A＝1，B＝1，x＝1 覆盖(4)(8)</p> <h4 id="基本路径测试"><a href="#基本路径测试" class="header-anchor">#</a> 基本路径测试</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141512444.png" alt="image.png"></p> <h4 id="控制流图"><a href="#控制流图" class="header-anchor">#</a> 控制流图</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141514110.png" alt="image.png"></p> <h4 id="程序流程图映射程序流图"><a href="#程序流程图映射程序流图" class="header-anchor">#</a> 程序流程图映射程序流图</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141514179.png" alt="image.png"></p> <h4 id="程序图g的环形复杂性v-g-计算"><a href="#程序图g的环形复杂性v-g-计算" class="header-anchor">#</a> 程序图G的环形复杂性V(G)计算</h4> <ul><li>三种方法：
<ul><li>V(G)等于程序图G的区域数</li> <li>V(G) = E - N + 2，E是程序图G的边数，N是程序图G的节点数</li> <li>V(G) = P + 1，P是程序图G中判定的节点数</li></ul></li></ul> <h4 id="循环测试"><a href="#循环测试" class="header-anchor">#</a> 循环测试</h4> <ul><li>简单循环</li> <li>嵌套循环</li> <li>串接循环</li> <li>无结构循环</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141522544.png" alt="image.png"></p> <h4 id="简单循环"><a href="#简单循环" class="header-anchor">#</a> 简单循环</h4> <ul><li>零次循环：从循环入口直接跳到循环出口</li> <li>一次循环：查找循环初始值方面的错误</li> <li>二次循环：检查在多次循环时才能暴露的错误</li> <li>m次循环：此时的m &lt; n，也是检查在多次循环时才能暴露的错误</li> <li>n(最大)次数循环、n + 1(比最大次数多一)次的循环，n - 1(比最大次数少一)次的循环</li></ul> <h4 id="嵌套循环"><a href="#嵌套循环" class="header-anchor">#</a> 嵌套循环</h4> <ul><li>从最内层循环开始，设置所有其他层的循环为最小值；</li> <li>对最内层循环做简单循环的全部测试。测试时保持所有外层循环的循环变量为最小值。另外，对越界值和非法值做类似的测试。</li> <li>逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取“典型”值。</li> <li>反复进行，直到所有各层循环测试完毕。</li> <li>对全部各层循环同时取最小循环次数，或者同时取最大循环次数。</li></ul> <h4 id="串接循环"><a href="#串接循环" class="header-anchor">#</a> 串接循环</h4> <ul><li>如果各个循环互相独立，则串接循环可以用与简单循环相同的方法进行测试。</li> <li>如果有两个循环处于串接状态，而前一个循环的循环变量的值是后一个循环的初值。则这几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理</li></ul> <h3 id="黑盒测试技术"><a href="#黑盒测试技术" class="header-anchor">#</a> 黑盒测试技术</h3> <ul><li><p>黑盒测试是根据程序组件的规格说明测试软件功能的方法所以也称为功能测试</p></li> <li><p>被测对象作为一个黑盒子，它的功能行为只能通过研究其输入和输出来确定，所以又称为软件输入/输出接口测试</p></li> <li><p>黑盒测试注重于功能和数据信息域的测试</p></li> <li><p><mark style="background:#FF5582A6;">等价类划分</mark></p></li> <li><p><mark style="background:#FF5582A6;">边值分析法</mark></p></li></ul> <h4 id="等价类划分"><a href="#等价类划分" class="header-anchor">#</a> 等价类划分</h4> <ul><li>由于不能穷举所有可能的输入数据来进行测试，所以只能选择少量有代表性的输入数据，来揭露尽可能多的程序错误</li> <li>等价类划分的办法是把程序的输入域或者输出域划分成若干等价类，然后从每个部分中选取少数代表性数据当作测试用例
<ul><li><span style="color:#01460f;">等价类是指输入域的某个子集，该子集中的每个输入数据对揭露软件中的错误都是等效的，测试等价类的某个代表值就等价于对这一类其他值的测试。</span></li> <li><span style="color:#01460f;">根据输出数据等价类导出输入数据等价类</span></li></ul></li></ul> <p><mark style="background:#ABF7F7A6;">等价划分</mark></p> <ul><li>将程序输入划分成若干个数据类，以生成测试用例</li> <li>等价类</li></ul> <h4 id="等价类划分原则"><a href="#等价类划分原则" class="header-anchor">#</a> 等价类划分原则</h4> <ul><li>等价类的划分有两种不同的情况：
<ul><li><span style="color:#ff0000;">有效等价类</span>：合理的，有意义的输入数据集合</li> <li><span style="color:#ff0000;">无效等价类</span>：不合理的，无意义的输入数据集合</li></ul></li> <li>在设计测试用例时，要同时考虑有效等价类和无效等价类的设计</li></ul> <p><mark style="background:#FF5582A6;">输入条件规定了取值范围</mark></p> <ul><li>可以确定一个有效等价类和两个无效等价类</li> <li>例如：在程序的规格说明中，对输入条件有一句话：
<span style="color:#ff0000;"> “…… 项数可以从1到999 ……” </span>
则：<span style="color:#ff0000;">有效等价类是“1≤项数≤999”</span> <span style="color:#ff0000;"> 两个无效等价类是“项数＜1”或“项数＞999”</span>。在数轴上表示成:
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141540060.png" alt="image.png"></li></ul> <p><mark style="background:#FF5582A6;">输入条件规定了输入值的集合</mark></p> <ul><li>可确立一个有效等价类和一个无效等价类</li> <li>例：在Pascal语言中对变量标识符规定为<span style="color:#ff0000;">“以字母打头的……串”。</span>
则：<span style="color:#ff0000;">所有以字母打头的构成有效等价类</span>，而<span style="color:#ff0000;">不在此集合内（不以字母打头）的归入无效等价类。</span></li></ul> <p><mark style="background:#FF5582A6;">如果规定了输入数据的一组值而且程序要对每个输入值分别进行处理</mark></p> <ul><li>为每一个输入值确立一个有效等价类</li> <li>针对这组值确立一个无效等价类，它是所有不允许的输入值的集合</li> <li>例如：在教师上岗方案中规定对教授、副教授、讲师和助教分别计算分数，做相应处理
则：可以确定<span style="color:#ff0000;">4个有效等价类为教授、副教授、讲师和助教</span>；<span style="color:#ff0000;">1个无效等价类</span>，它是<span style="color:#ff0000;">所有不符合以上身份的人员的输入值的集合</span>。</li></ul> <p><mark style="background:#FF5582A6;">如果规定了输入数据必须遵守的规则</mark></p> <ul><li>可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</li> <li>例：Pascal语言规定 “一个语句必须以分号‘;’结束”
则：可以确定<span style="color:#ff0000;">一个有效等价类 “以‘;’结束”</span>，<span style="color:#ff0000;">若干个无效等价类 “以‘:’结束”、“以‘,’结束”、“以‘ ’结束”、“以LF结束”等。</span></li></ul> <h4 id="设计测试用例"><a href="#设计测试用例" class="header-anchor">#</a> 设计测试用例</h4> <ul><li>从划分出的等价类中按以下原则选择测试用例：
<ul><li>为每个等价类规定一个唯一的编号</li> <li>设计一个新的测试用例，使其<span style="color:#ff0000;">尽可能多地覆盖尚未覆盖的有效等价类</span>，重复这一步，直到所有有效等价类被覆盖为止</li> <li>设计一个新的测试用例，使其<span style="color:#ff0000;">仅覆盖一个尚未被覆盖的无效等价类</span>，重复这一步，直到所有的无效等价类都被覆盖为止</li></ul></li></ul> <h4 id="举例"><a href="#举例" class="header-anchor">#</a> 举例</h4> <blockquote><p>某报表处理系统要求用户输入处理报表的日期,日期限制在2003年1月至2008年12月，即系统只能对该段期间内的报表进行处理，如日期不在此范围内，则显示输入错误信息。系统日期规定由年、月的6位数字字符组成，前四位代表年，后两位代表月。
如何用等价类划分法设计测试用例,来测试程序的日期检查功能？</p></blockquote> <h5 id="等价类划分-2"><a href="#等价类划分-2" class="header-anchor">#</a> 等价类划分</h5> <table><thead><tr><th>输入条件</th> <th>有效等价类</th> <th>无效等价类</th></tr></thead> <tbody><tr><td>报表日期的类型及长度</td> <td><span style="color:#ff0000;">6位数字字符(1)</span></td> <td><span style="color:#ff0000;">有非数字字符(4)<br>少于6个数字字符(5)<br>多于6个数字字符(6)</span></td></tr> <tr><td>年份范围</td> <td><span style="color:#ff0000;">在2003~2008之间(2)</span></td> <td><span style="color:#ff0000;">少于2003(7)<br>大于2008</span></td></tr> <tr><td>月份范围</td> <td><span style="color:#ff0000;">在1~12之间(3)</span></td> <td><span style="color:#ff0000;">小于1(9)<br>大于12(10)</span></td></tr></tbody></table> <h5 id="设计测试用例-2"><a href="#设计测试用例-2" class="header-anchor">#</a> 设计测试用例</h5> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141600547.png" alt="image.png"></p> <h4 id="边界值分析"><a href="#边界值分析" class="header-anchor">#</a> 边界值分析</h4> <ul><li><span style="color:#ff0000;">大量的错误是发生在输入或输出范围的边界上</span>，边界值揭露程序中错误的可能性就更大，边值分析法是对等价类划分方法的补充，这种情况下，测试用例来自<span style="color:#ff0000;">等价类的边界</span>。</li> <li>应当选取正好等于，刚刚大于，刚刚小于边界的值做为测试</li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306141604471.png" alt="image.png"></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件" class="sidebar-link reco-side-什么是软件" data-v-b57cc07c>什么是软件</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件危机" class="sidebar-link reco-side-什么是软件危机" data-v-b57cc07c>什么是软件危机</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件工程" class="sidebar-link reco-side-什么是软件工程" data-v-b57cc07c>什么是软件工程</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件工程的内容" class="sidebar-link reco-side-软件工程的内容" data-v-b57cc07c>软件工程的内容</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件工具" class="sidebar-link reco-side-软件工具" data-v-b57cc07c>软件工具</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件工程方法" class="sidebar-link reco-side-软件工程方法" data-v-b57cc07c>软件工程方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#框架活动" class="sidebar-link reco-side-框架活动" data-v-b57cc07c>框架活动</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件生命周期" class="sidebar-link reco-side-软件生命周期" data-v-b57cc07c>软件生命周期</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件工程三要素" class="sidebar-link reco-side-软件工程三要素" data-v-b57cc07c>软件工程三要素</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件生命周期模型" class="sidebar-link reco-side-软件生命周期模型" data-v-b57cc07c>软件生命周期模型</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#作业1" class="sidebar-link reco-side-作业1" data-v-b57cc07c>作业1</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件过程" class="sidebar-link reco-side-什么是软件过程" data-v-b57cc07c>什么是软件过程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#通用活动" class="sidebar-link reco-side-通用活动" data-v-b57cc07c>通用活动</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件过程模型" class="sidebar-link reco-side-软件过程模型" data-v-b57cc07c>软件过程模型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#通用过程模型" class="sidebar-link reco-side-通用过程模型" data-v-b57cc07c>通用过程模型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#过程流" class="sidebar-link reco-side-过程流" data-v-b57cc07c>过程流</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#过程模型" class="sidebar-link reco-side-过程模型" data-v-b57cc07c>过程模型</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#作业2" class="sidebar-link reco-side-作业2" data-v-b57cc07c>作业2</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#非敏捷-瀑布式开发" class="sidebar-link reco-side-非敏捷-瀑布式开发" data-v-b57cc07c>非敏捷——瀑布式开发</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#敏捷过程是什么" class="sidebar-link reco-side-敏捷过程是什么" data-v-b57cc07c>敏捷过程是什么</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#极限编程xp" class="sidebar-link reco-side-极限编程xp" data-v-b57cc07c>极限编程XP</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#scrum是什么" class="sidebar-link reco-side-scrum是什么" data-v-b57cc07c>Scrum是什么</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求分析为什么困难" class="sidebar-link reco-side-需求分析为什么困难" data-v-b57cc07c>需求分析为什么困难？</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件需求" class="sidebar-link reco-side-什么是软件需求" data-v-b57cc07c>什么是软件需求</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件需求的定义" class="sidebar-link reco-side-软件需求的定义" data-v-b57cc07c>软件需求的定义</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件需求" class="sidebar-link reco-side-软件需求" data-v-b57cc07c>软件需求</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件需求的分类" class="sidebar-link reco-side-软件需求的分类" data-v-b57cc07c>软件需求的分类</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求工程" class="sidebar-link reco-side-需求工程" data-v-b57cc07c>需求工程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求工程的基本活动" class="sidebar-link reco-side-需求工程的基本活动" data-v-b57cc07c>需求工程的基本活动</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求获取技术" class="sidebar-link reco-side-需求获取技术" data-v-b57cc07c>需求获取技术</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#竞争性需求分析" class="sidebar-link reco-side-竞争性需求分析" data-v-b57cc07c>竞争性需求分析</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#竞争性需求分析nabcd-model" class="sidebar-link reco-side-竞争性需求分析nabcd-model" data-v-b57cc07c>竞争性需求分析NABCD model</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求规格说明书" class="sidebar-link reco-side-需求规格说明书" data-v-b57cc07c>需求规格说明书</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求规格说明书的作用" class="sidebar-link reco-side-需求规格说明书的作用" data-v-b57cc07c>需求规格说明书的作用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求规格说明语言" class="sidebar-link reco-side-需求规格说明语言" data-v-b57cc07c>需求规格说明语言</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求规格的主要内容" class="sidebar-link reco-side-需求规格的主要内容" data-v-b57cc07c>需求规格的主要内容</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求建模概述" class="sidebar-link reco-side-需求建模概述" data-v-b57cc07c>需求建模概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#概述" class="sidebar-link reco-side-概述" data-v-b57cc07c>概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求建模的经验原则" class="sidebar-link reco-side-需求建模的经验原则" data-v-b57cc07c>需求建模的经验原则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#需求建模的元素" class="sidebar-link reco-side-需求建模的元素" data-v-b57cc07c>需求建模的元素</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#基于场景的建模" class="sidebar-link reco-side-基于场景的建模" data-v-b57cc07c>基于场景的建模</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#基本概念" class="sidebar-link reco-side-基本概念" data-v-b57cc07c>基本概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#用例建模步骤" class="sidebar-link reco-side-用例建模步骤" data-v-b57cc07c>用例建模步骤</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#用例建模案例-出卷系统" class="sidebar-link reco-side-用例建模案例-出卷系统" data-v-b57cc07c>用例建模案例——出卷系统</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#基于数据流的建模" class="sidebar-link reco-side-基于数据流的建模" data-v-b57cc07c>基于数据流的建模</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#结构化方法概述" class="sidebar-link reco-side-结构化方法概述" data-v-b57cc07c>结构化方法概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#结构化分析方法" class="sidebar-link reco-side-结构化分析方法" data-v-b57cc07c>结构化分析方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#抽象与分解" class="sidebar-link reco-side-抽象与分解" data-v-b57cc07c>抽象与分解</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#结构化分析模型" class="sidebar-link reco-side-结构化分析模型" data-v-b57cc07c>结构化分析模型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流图符号" class="sidebar-link reco-side-数据流图符号" data-v-b57cc07c>数据流图符号</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流图举例" class="sidebar-link reco-side-数据流图举例" data-v-b57cc07c>数据流图举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流图的各个层次" class="sidebar-link reco-side-数据流图的各个层次" data-v-b57cc07c>数据流图的各个层次</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#图和加工的编号" class="sidebar-link reco-side-图和加工的编号" data-v-b57cc07c>图和加工的编号</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#分层数据流图示例-资格和水平考试的考务处理系统" class="sidebar-link reco-side-分层数据流图示例-资格和水平考试的考务处理系统" data-v-b57cc07c>分层数据流图示例——资格和水平考试的考务处理系统</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#课堂练习" class="sidebar-link reco-side-课堂练习" data-v-b57cc07c>课堂练习</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#总结-画分层数据流图的步骤" class="sidebar-link reco-side-总结-画分层数据流图的步骤" data-v-b57cc07c>总结：画分层数据流图的步骤</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据字典" class="sidebar-link reco-side-数据字典" data-v-b57cc07c>数据字典</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#定义数据组成的符号" class="sidebar-link reco-side-定义数据组成的符号" data-v-b57cc07c>定义数据组成的符号</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流组成示例-学校电话号码" class="sidebar-link reco-side-数据流组成示例-学校电话号码" data-v-b57cc07c>数据流组成示例（学校电话号码）</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流组成示例-发票" class="sidebar-link reco-side-数据流组成示例-发票" data-v-b57cc07c>数据流组成示例（发票）</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#字典条目" class="sidebar-link reco-side-字典条目" data-v-b57cc07c>字典条目</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流条目的描述内容" class="sidebar-link reco-side-数据流条目的描述内容" data-v-b57cc07c>数据流条目的描述内容</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流组成" class="sidebar-link reco-side-数据流组成" data-v-b57cc07c>数据流组成</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#文件条目的描述内容" class="sidebar-link reco-side-文件条目的描述内容" data-v-b57cc07c>文件条目的描述内容</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据项条目的描述内容" class="sidebar-link reco-side-数据项条目的描述内容" data-v-b57cc07c>数据项条目的描述内容</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#加工条目的描述内容" class="sidebar-link reco-side-加工条目的描述内容" data-v-b57cc07c>加工条目的描述内容</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#源点或终点条目的描述内容" class="sidebar-link reco-side-源点或终点条目的描述内容" data-v-b57cc07c>源点或终点条目的描述内容</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#基于数据的建模" class="sidebar-link reco-side-基于数据的建模" data-v-b57cc07c>基于数据的建模</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#面向数据的建模方法" class="sidebar-link reco-side-面向数据的建模方法" data-v-b57cc07c>面向数据的建模方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#面向状态的建模方法" class="sidebar-link reco-side-面向状态的建模方法" data-v-b57cc07c>面向状态的建模方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#作业3" class="sidebar-link reco-side-作业3" data-v-b57cc07c>作业3</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件设计概念" class="sidebar-link reco-side-软件设计概念" data-v-b57cc07c>软件设计概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件设计" class="sidebar-link reco-side-什么是软件设计" data-v-b57cc07c>什么是软件设计?</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#设计" class="sidebar-link reco-side-设计" data-v-b57cc07c>设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#良好设计应具备的特征" class="sidebar-link reco-side-良好设计应具备的特征" data-v-b57cc07c>良好设计应具备的特征</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#设计质量指导原则" class="sidebar-link reco-side-设计质量指导原则" data-v-b57cc07c>设计质量指导原则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#设计概念" class="sidebar-link reco-side-设计概念" data-v-b57cc07c>设计概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#体系结构" class="sidebar-link reco-side-体系结构" data-v-b57cc07c>体系结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#设计模式" class="sidebar-link reco-side-设计模式" data-v-b57cc07c>设计模式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#关注点分离" class="sidebar-link reco-side-关注点分离" data-v-b57cc07c>关注点分离</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#模块化" class="sidebar-link reco-side-模块化" data-v-b57cc07c>模块化</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#通过模块化降低开发复杂度" class="sidebar-link reco-side-通过模块化降低开发复杂度" data-v-b57cc07c>通过模块化降低开发复杂度</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#无限制地进行模块化分" class="sidebar-link reco-side-无限制地进行模块化分" data-v-b57cc07c>无限制地进行模块化分？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#信息隐蔽" class="sidebar-link reco-side-信息隐蔽" data-v-b57cc07c>信息隐蔽</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#为什么隐蔽信息" class="sidebar-link reco-side-为什么隐蔽信息" data-v-b57cc07c>为什么隐蔽信息？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#功能独立" class="sidebar-link reco-side-功能独立" data-v-b57cc07c>功能独立</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#方面" class="sidebar-link reco-side-方面" data-v-b57cc07c>方面</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#重构" class="sidebar-link reco-side-重构" data-v-b57cc07c>重构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#面向对象的设计概念" class="sidebar-link reco-side-面向对象的设计概念" data-v-b57cc07c>面向对象的设计概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#设计任务" class="sidebar-link reco-side-设计任务" data-v-b57cc07c>设计任务</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#体系结构风格" class="sidebar-link reco-side-体系结构风格" data-v-b57cc07c>体系结构风格</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#以数据为中心的体系结构" class="sidebar-link reco-side-以数据为中心的体系结构" data-v-b57cc07c>以数据为中心的体系结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流体系结构" class="sidebar-link reco-side-数据流体系结构" data-v-b57cc07c>数据流体系结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#调用和返回体系结构" class="sidebar-link reco-side-调用和返回体系结构" data-v-b57cc07c>调用和返回体系结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#层次体系结构" class="sidebar-link reco-side-层次体系结构" data-v-b57cc07c>层次体系结构</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#体系结构设计-2" class="sidebar-link reco-side-体系结构设计-2" data-v-b57cc07c>体系结构设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#构建化设计" class="sidebar-link reco-side-构建化设计" data-v-b57cc07c>构建化设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#数据流图映射到结构图的步骤" class="sidebar-link reco-side-数据流图映射到结构图的步骤" data-v-b57cc07c>数据流图映射到结构图的步骤</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#构件级设计-2" class="sidebar-link reco-side-构件级设计-2" data-v-b57cc07c>构件级设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#理解构件设计" class="sidebar-link reco-side-理解构件设计" data-v-b57cc07c>理解构件设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是构件" class="sidebar-link reco-side-什么是构件" data-v-b57cc07c>什么是构件</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#基本设计原则" class="sidebar-link reco-side-基本设计原则" data-v-b57cc07c>基本设计原则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#内聚性" class="sidebar-link reco-side-内聚性" data-v-b57cc07c>内聚性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#耦合性" class="sidebar-link reco-side-耦合性" data-v-b57cc07c>耦合性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#设计传统构件" class="sidebar-link reco-side-设计传统构件" data-v-b57cc07c>设计传统构件</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#处理逻辑的表示工具" class="sidebar-link reco-side-处理逻辑的表示工具" data-v-b57cc07c>处理逻辑的表示工具</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#用户界面设计" class="sidebar-link reco-side-用户界面设计" data-v-b57cc07c>用户界面设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#界面设计" class="sidebar-link reco-side-界面设计" data-v-b57cc07c>界面设计</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#黄金规则" class="sidebar-link reco-side-黄金规则" data-v-b57cc07c>黄金规则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#任务分析和建模" class="sidebar-link reco-side-任务分析和建模" data-v-b57cc07c>任务分析和建模</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#基本概念-2" class="sidebar-link reco-side-基本概念-2" data-v-b57cc07c>基本概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#什么是软件测试" class="sidebar-link reco-side-什么是软件测试" data-v-b57cc07c>什么是软件测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#有关软件测试的错误观点" class="sidebar-link reco-side-有关软件测试的错误观点" data-v-b57cc07c>有关软件测试的错误观点</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件测试原则" class="sidebar-link reco-side-软件测试原则" data-v-b57cc07c>软件测试原则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#测试用例" class="sidebar-link reco-side-测试用例" data-v-b57cc07c>测试用例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#测试用例设计" class="sidebar-link reco-side-测试用例设计" data-v-b57cc07c>测试用例设计</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件测试的分类" class="sidebar-link reco-side-软件测试的分类" data-v-b57cc07c>软件测试的分类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#按测试方式分类" class="sidebar-link reco-side-按测试方式分类" data-v-b57cc07c>按测试方式分类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#按测试过程分类" class="sidebar-link reco-side-按测试过程分类" data-v-b57cc07c>按测试过程分类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#按测试目的分类" class="sidebar-link reco-side-按测试目的分类" data-v-b57cc07c>按测试目的分类</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#测试策略" class="sidebar-link reco-side-测试策略" data-v-b57cc07c>测试策略</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#软件测试的组织" class="sidebar-link reco-side-软件测试的组织" data-v-b57cc07c>软件测试的组织</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#测试完成的标准" class="sidebar-link reco-side-测试完成的标准" data-v-b57cc07c>测试完成的标准</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#测试策略-2" class="sidebar-link reco-side-测试策略-2" data-v-b57cc07c>测试策略</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#单元测试" class="sidebar-link reco-side-单元测试" data-v-b57cc07c>单元测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#集成测试" class="sidebar-link reco-side-集成测试" data-v-b57cc07c>集成测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#回归测试" class="sidebar-link reco-side-回归测试" data-v-b57cc07c>回归测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#冒烟测试" class="sidebar-link reco-side-冒烟测试" data-v-b57cc07c>冒烟测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#面向对象软件的测试" class="sidebar-link reco-side-面向对象软件的测试" data-v-b57cc07c>面向对象软件的测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#确认测试" class="sidebar-link reco-side-确认测试" data-v-b57cc07c>确认测试</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#系统测试" class="sidebar-link reco-side-系统测试" data-v-b57cc07c>系统测试</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/6.html#测试方法" class="sidebar-link reco-side-测试方法" data-v-b57cc07c>测试方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#白盒测试技术" class="sidebar-link reco-side-白盒测试技术" data-v-b57cc07c>白盒测试技术</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/6.html#黑盒测试技术" class="sidebar-link reco-side-黑盒测试技术" data-v-b57cc07c>黑盒测试技术</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="https://yelishu.gitee.io/blogs/bg.mp3" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="https://p2.music.126.net/ZvYHj8W72RwrnOJiOGaL9g==/109951163074555333.jpg?param=130y130" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(https://p2.music.126.net/ZvYHj8W72RwrnOJiOGaL9g==/109951163074555333.jpg?param=130y130);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>❀</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>nevva</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/blogs/assets/js/app.b10d3b76.js" defer></script><script src="/blogs/assets/js/7.51cf2bb3.js" defer></script><script src="/blogs/assets/js/2.90913472.js" defer></script><script src="/blogs/assets/js/1.c35ebe2c.js" defer></script><script src="/blogs/assets/js/67.fecbf0ba.js" defer></script>
  </body>
</html>
