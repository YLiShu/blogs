<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机系统基础 | 黎子🌰码境</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="shortcut icon" href="favicon.ico">
    <meta name="description" content="在代码的迷宫中穿梭，书写着改变生活的数字篇章">
    
    <link rel="preload" href="/blogs/assets/css/0.styles.d9a4f19e.css" as="style"><link rel="preload" href="/blogs/assets/js/app.b10d3b76.js" as="script"><link rel="preload" href="/blogs/assets/js/7.51cf2bb3.js" as="script"><link rel="preload" href="/blogs/assets/js/2.90913472.js" as="script"><link rel="preload" href="/blogs/assets/js/1.c35ebe2c.js" as="script"><link rel="preload" href="/blogs/assets/js/46.0eead14d.js" as="script"><link rel="prefetch" href="/blogs/assets/js/10.51f51c0e.js"><link rel="prefetch" href="/blogs/assets/js/11.f1c4e2ce.js"><link rel="prefetch" href="/blogs/assets/js/14.90b34deb.js"><link rel="prefetch" href="/blogs/assets/js/15.cd05d3f7.js"><link rel="prefetch" href="/blogs/assets/js/16.0ca60d78.js"><link rel="prefetch" href="/blogs/assets/js/17.26773bd0.js"><link rel="prefetch" href="/blogs/assets/js/18.21df733a.js"><link rel="prefetch" href="/blogs/assets/js/19.eed3c532.js"><link rel="prefetch" href="/blogs/assets/js/20.4c76e8be.js"><link rel="prefetch" href="/blogs/assets/js/21.f18babb4.js"><link rel="prefetch" href="/blogs/assets/js/22.249f648e.js"><link rel="prefetch" href="/blogs/assets/js/23.cb41f22a.js"><link rel="prefetch" href="/blogs/assets/js/24.c95ba296.js"><link rel="prefetch" href="/blogs/assets/js/25.4a450405.js"><link rel="prefetch" href="/blogs/assets/js/26.b1851237.js"><link rel="prefetch" href="/blogs/assets/js/27.ab146b7f.js"><link rel="prefetch" href="/blogs/assets/js/28.83af5ecf.js"><link rel="prefetch" href="/blogs/assets/js/29.17c1b3c2.js"><link rel="prefetch" href="/blogs/assets/js/3.8ff04919.js"><link rel="prefetch" href="/blogs/assets/js/30.5a702d15.js"><link rel="prefetch" href="/blogs/assets/js/31.9b363f9c.js"><link rel="prefetch" href="/blogs/assets/js/32.df071e6e.js"><link rel="prefetch" href="/blogs/assets/js/33.83f13db0.js"><link rel="prefetch" href="/blogs/assets/js/34.a5e21847.js"><link rel="prefetch" href="/blogs/assets/js/35.caa9411a.js"><link rel="prefetch" href="/blogs/assets/js/36.0997f85f.js"><link rel="prefetch" href="/blogs/assets/js/37.41a69cda.js"><link rel="prefetch" href="/blogs/assets/js/38.11c97fc9.js"><link rel="prefetch" href="/blogs/assets/js/39.c7a91778.js"><link rel="prefetch" href="/blogs/assets/js/4.7ab60d34.js"><link rel="prefetch" href="/blogs/assets/js/40.788bd3bb.js"><link rel="prefetch" href="/blogs/assets/js/41.bfd620d2.js"><link rel="prefetch" href="/blogs/assets/js/42.a93d1dad.js"><link rel="prefetch" href="/blogs/assets/js/43.36e369c4.js"><link rel="prefetch" href="/blogs/assets/js/44.a8c7c1be.js"><link rel="prefetch" href="/blogs/assets/js/45.be0bd724.js"><link rel="prefetch" href="/blogs/assets/js/47.9c0b8ec3.js"><link rel="prefetch" href="/blogs/assets/js/48.fedde897.js"><link rel="prefetch" href="/blogs/assets/js/49.658232de.js"><link rel="prefetch" href="/blogs/assets/js/5.07521870.js"><link rel="prefetch" href="/blogs/assets/js/50.e75baace.js"><link rel="prefetch" href="/blogs/assets/js/51.39f09a2a.js"><link rel="prefetch" href="/blogs/assets/js/52.86d8775b.js"><link rel="prefetch" href="/blogs/assets/js/53.2bcea0af.js"><link rel="prefetch" href="/blogs/assets/js/54.80cfc079.js"><link rel="prefetch" href="/blogs/assets/js/55.575fad98.js"><link rel="prefetch" href="/blogs/assets/js/56.a9ac12aa.js"><link rel="prefetch" href="/blogs/assets/js/57.bc25fe73.js"><link rel="prefetch" href="/blogs/assets/js/58.a1f3dfda.js"><link rel="prefetch" href="/blogs/assets/js/59.acfc0f60.js"><link rel="prefetch" href="/blogs/assets/js/6.7070ea7f.js"><link rel="prefetch" href="/blogs/assets/js/60.cfc92fb7.js"><link rel="prefetch" href="/blogs/assets/js/61.566a8f66.js"><link rel="prefetch" href="/blogs/assets/js/62.1c3ab2d6.js"><link rel="prefetch" href="/blogs/assets/js/63.f1df4d25.js"><link rel="prefetch" href="/blogs/assets/js/64.349b7d3b.js"><link rel="prefetch" href="/blogs/assets/js/65.3e277b74.js"><link rel="prefetch" href="/blogs/assets/js/66.f985ae29.js"><link rel="prefetch" href="/blogs/assets/js/67.fecbf0ba.js"><link rel="prefetch" href="/blogs/assets/js/68.1f08c812.js"><link rel="prefetch" href="/blogs/assets/js/69.55f47746.js"><link rel="prefetch" href="/blogs/assets/js/70.66e490da.js"><link rel="prefetch" href="/blogs/assets/js/8.8dfb1e90.js"><link rel="prefetch" href="/blogs/assets/js/9.18b271e2.js"><link rel="prefetch" href="/blogs/assets/js/vendors~docsearch.814a0df0.js">
    <link rel="stylesheet" href="/blogs/assets/css/0.styles.d9a4f19e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>黎子🌰码境</h3> <p class="description" data-v-59e6cb88>在代码的迷宫中穿梭，书写着改变生活的数字篇章</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>黎子</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blogs/" class="home-link router-link-active"><img src="/blogs/avatar.jpg" alt="黎子🌰码境" class="logo"> <span class="site-name">黎子🌰码境</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/计算机网络/" class="nav-link"><i class="undefined"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/学校课程/" class="nav-link"><i class="undefined"></i>
  学校课程
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      黎子🌰Code
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3206591176245848" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/YLiShu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/blogs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/blogs/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    黎子
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>32</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>18</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/计算机网络/" class="nav-link"><i class="undefined"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/学校课程/" class="nav-link"><i class="undefined"></i>
  学校课程
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      黎子🌰Code
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3206591176245848" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/YLiShu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/blogs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>计算机系统基础</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>黎子</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">计算机系统基础</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>黎子</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/11/13</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>计算机系统基础</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="第一章-计算机系统概论"><a href="#第一章-计算机系统概论" class="header-anchor">#</a> 第一章 计算机系统概论</h1> <h2 id="现代计算机的原型"><a href="#现代计算机的原型" class="header-anchor">#</a> 现代计算机的原型</h2> <p><strong>冯诺依曼结构最重要的思想是什么？</strong></p> <ul><li><strong>“存储程序”</strong> 工作方式：<font color="red">任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需要操作人员干预下，自动完成逐条取出指令和执行指令的任务。</font></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1684895661907.png" alt="1684895661907.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1684895895285.png" alt="1684895895285.png"></p> <p><strong>冯诺依曼结构的主要思想</strong></p> <ul><li>计算机应由<font color="red">运算器、控制器、存储器、输入设备和输出设备</font>五个基本部件组成</li> <li>各基本部件的功能是：
<ul><li>存储器不仅能存放数据，也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令</li> <li>控制器应能自动取出指令来执行</li> <li>运算器应能进行加/减/乘/除四种基本算术运算，并且能进行一些逻辑运算和附加运算</li> <li>操作人员可以通过输入设备、输出设备和主机进行通信</li></ul></li> <li>内部以<font color="red">二进制</font>表示指令和数据。每条指令由<font color="red">操作码</font>和<font color="red">地址码</font>两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序</li> <li>采用<font color="red">“存储程序”</font>工作方式</li></ul> <p><strong>现代计算机结构模型</strong></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686017890476.png" alt="1686017890476.png"></p> <ul><li>ALU：算术逻辑部件</li> <li>GPRs：通用寄存器组</li> <li>IR：指令寄存器</li> <li>PC：程序计数器</li> <li>MAR：存储器地址寄存器</li> <li>MDR：存储器数据寄存器</li></ul> <p><strong>计算机是如何工作的？</strong></p> <ul><li>程序执行前
<ul><li>数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放，指令由OP（操作码）、ADDR（地址码）字段组成，程序起始地址置PC</li></ul></li> <li>开始执行程序
<ul><li>第一步：根据PC取指令</li> <li>第二步：指令译码</li> <li>第三步：取操作数</li> <li>第四步：取指令执行</li> <li>第五步：回写结果</li> <li>第六步：修改PC的值，继续执行下一条指令</li></ul></li></ul> <p><strong>指令和数据</strong></p> <ul><li>程序启动前，指令和数据都存放在存储器中，形式上没有差别，都是0/1序列</li> <li>采用<font color="red">”存储程序“</font>工作方式：
<ul><li><font color="blue">程序由指令组成，程序被启动后，计算机能自动取出一条一条的指令执行，在执行过程中无需人的干预。</font></li></ul></li> <li><font color="red">指令中需要给出的信息：</font> <ul><li><font color="blue">操作性质（操作码）</font></li> <li><font color="blue">源操作数1</font>或/和<font color="blue">源操作数2</font><font color="green">（立即数、寄存器编号、存储地址）</font></li> <li><font color="blue">目的操作数地址</font><font color="green">（寄存器编号、存储地址）</font></li> <li>存储地址的描述与<font color="red">操作数的数据结构</font>有关</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686020057774.png" alt="1686020057774.png"></p> <blockquote><ol><li>对于R型指令，根据功能说明，可以实现寄存器之间的算术逻辑运算，包括加、减、与、或等操作。具体来说，根据op字段指定的操作码，可以实现R[rt]←R[rt] op R[rs]（将目标寄存器R[rt]中的值和源寄存器R[rs]中的值进行op运算，然后将运算结果存储到目标寄存器R[rt]中）或R[rt]←R[rs]（将源寄存器R[rs]中的值直接复制到目标寄存器R[rt]中，这种情况下op字段不起作用，可以设置为任意值。）操作，将运算结果存储到目标寄存器R[rt]中。</li> <li>对于M型指令，根据功能说明，可以实现存储器和寄存器之间的数据传输，包括村存储器中读取数据或将寄存器中的数据写入存储器中。具体来说，根据op字段指定的操作码，可以实现R[0]←M[addr]或M[addr]←R[0]操作，将存储器中指定地址addr处的数据读入寄存器R[0]中或将寄存器R[0]中的数据写入存储器中指定地址addr处。</li></ol></blockquote> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686022225471.png" alt="1686022225471.png"></p> <table><thead><tr><th>主存地址</th> <th>主存单元   内容</th> <th>内容说明（Ii表示第i条指令）</th> <th>指令的符号   表示</th></tr></thead> <tbody><tr><td>0</td> <td>1110 0110</td> <td>I1：   R[0] ←   M[6]；op=1110：取数操作</td> <td>load r0, 6#</td></tr> <tr><td>1</td> <td>0000 0100</td> <td>I2：   R[1] ←   R[0]；op=0000：传送操作</td> <td>mov r1, r0</td></tr> <tr><td>2</td> <td>1110 0101</td> <td>I3：   R[0] ←   M[5]；op=1110：取数操作</td> <td>load r0, 5#</td></tr> <tr><td>3</td> <td>0001 0001</td> <td>I4：   R[0] ←   R[0] + R[1]；op=0001：加操作</td> <td>add r0, r1</td></tr> <tr><td>4</td> <td>1111 0111</td> <td>I5：   M[7]←   R[0]；op=1111：存数操作</td> <td>store 7#, r0</td></tr></tbody></table> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686022444589.png" alt="1686022444589.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686022568046.png" alt="1686022568046.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686022639645.png" alt="1686022639645.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686022709921.png" alt="1686022709921.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686022871334.png" alt="1686022871334.png"></p> <p><strong>用汇编语言开发程序</strong></p> <ul><li>汇编语言（源）程序由<font color="red">汇编指令</font>构成</li> <li><font color="red">汇编指令是指用助记符和标号来表示的指令（与机器指令一一对应）</font></li></ul> <p>指令是指：</p> <ul><li>包含操作码和操作数或其地址码（<font color="red">机器指令用二进制表示，汇编指令用符号表示</font>）</li> <li>只能描述：
<ul><li>取（或存一个数）</li> <li>两个数加（或减、乘、除、与、或等）</li> <li>根据运算结果判断是否转移执行</li></ul></li></ul> <p>汇编语言出现：</p> <ul><li>用助记符表示操作码</li> <li>用标号表示位置</li> <li>用助记符表示寄存器</li></ul> <p>汇编的优缺点</p> <p>优点</p> <ul><li>不会因为增减指令而需要修改其他指令</li> <li>不需记忆指令码，编写方便</li> <li>可读性比机器语言强</li></ul> <p>缺点：</p> <ul><li>需要将汇编语言转换为机器语言</li> <li>用汇编程序转换</li></ul> <p><strong><font color="red">机器语言和汇编语言都是面向机器结构的语言，故它们统称为机器级语言</font></strong></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686023999899.png" alt="1686023999899.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/1686024360599.png" alt="1686024360599.png"></p> <p><strong>计算机系统抽象层的转换</strong></p> <ul><li>程序执行的结构不仅取决于<font color="red">算法、程序编写</font>而且取决于<font color="red">语言处理系统、操作系统、ISA（指令集体系结构）、微体系结构</font></li> <li>功能转换：上层是下层的抽象，下层是上层的实现，<font color="red">底层为上层提供支撑环境</font></li></ul> <p><strong>计算机系统的不同用户</strong> <font color="red">最终用户</font>工作在由应用程序提供的最上面的抽象层
<font color="red">系统管理员</font>工作在由操作系统提供的抽象层
<font color="red">应用程序员</font>工作在由语言处理系统（<font color="blue">主要有编译器和汇编器</font>）提供的抽象层
<font color="green">语言处理系统</font>建立在<font color="green">操作系统</font>之上
<font color="red">ISA处于软件和硬件的交界面（接口）</font> <font color="red">ISA是对硬件的抽象，所有软件功能都建立在ISA之上</font> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230607102049.png" alt="image.png"></p> <p><strong>指令集体系结构（ISA）</strong></p> <ul><li>ISA是指<font color="red">指令集体系结构</font>，简称<font color="red">指令系统</font></li> <li>ISA是一种规约，它规定了<font color="red">如何使用硬件</font> <ul><li>可执行的指令集合，包括<font color="red">指令格式、操作种类</font>以及每种操作对应的操作数的相应规定</li> <li>指令可以接受的<font color="red">操作数的类型</font></li> <li>操作数所能存放的寄存器组的结构，包括每个<font color="red">寄存器的名称、编号、长度和用途</font></li> <li>操作数所能存放的<font color="red">存储空间的大小和编址方式</font></li> <li>操作数在存储空间存放时按照<font color="red">大端还是小端方式存放</font></li> <li>指令获取操作数的方式，即<font color="red">寻址方式</font></li> <li>指令执行过程的控制方式，包括<font color="red">程序计数器（PC）、条件码 定义</font>等</li></ul></li></ul> <p><strong>计算机系统核心层之间的关联</strong>
ABI是为运行在<font color="blue">特定ISA及特定操作系统之上</font>的应用程序中所遵循的一种<font color="red">机器级目标代码层接口</font>
描述了<font color="blue">应用程序和操作系统之间</font>、<font color="red">应用程序和所调用的库之间</font>、<font color="green">不同组成部分（如过程或函数）之间</font>在较低层次上的机器级代码接口</p> <p><strong>计算机性能的基本评价指标</strong> <font color="red">吞吐率</font>和<font color="red">响应时间</font>是考量一个计算机系统性能的两个<font color="red">基本指标</font>。</p> <p><font color="red">吞吐率</font>表示<font color="green">单位时间内所完成的工作量</font>，类似的概念是<font color="red">带宽</font>，它表示<font color="green">单位时间内所传输
的信息量</font></p> <p><font color="red">响应时间</font>是指<font color="green">从作业提交开始到作业完成所用的时间</font>，类似的概念是<font color="red">执行时间</font>和<font color="red">等待时间</font>，它们都是用来表示<font color="green">一个任务所用的时间的度量值</font>。</p> <p><font color="red">CPU时间</font>指<font color="green">CPU用于本程序执行的时间</font>，它又包括以下两部分：
①<font color="red">用户CPU时间</font>，指<font color="green">真正用于运行用户程序代码的时间</font>
②<font color="red">系统CPU时间</font>，指<font color="green">为了执行用户程序而需要CPU运行操作系统程序的时间</font>。
<font color="red">其他时间</font>指<font color="green">等待I/O操作完成的时间或CPU用于执行其他用户程序的时间</font>。</p> <p>计算机系统性能评价主要考虑的是CPU性能，系统性能和CPU性能<font color="red">并不等价</font>，<font color="red">系统性能</font>指系统的响应时间；而<font color="red">CPU性能</font>是指用户CPU时间</p> <p><font color="red">基本的性能评价标准是：CPU的执行时间</font> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230607111948.png" alt="image.png">
机器Y的执行时间是X的n倍</p> <p><font color="red">时钟周期：</font>计算机必须能够产生同步的时钟定时信号，也就是CPU的主脉冲信号，其宽度称为时钟周期</p> <p><font color="red">时钟频率：</font>CPU的<font color="red">主频</font>就是CPU中的主脉冲信号的时钟频率，是CPU时钟周期的倒数</p> <p><font color="red">CPI：</font>CPI表示执行一条指令所需的时钟周期数。由于不同指令的功能不同，所需的时钟周期数也不同，因此，对于一个特定指令而言，其CPI指执行该指令所需的时钟周期数，此时CPI是一个确定的值；对于一个程序或一台机器来说，其CPI指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，此时CPI是一个平均值</p> <p><font color="red">用户CPU时间 = 程序总时钟周期数 ÷ 时钟频率 = 程序总时钟周期数 × 时钟周期</font>
已知程序总指令条数和综合CPI，则可用如下公式计算程序总时钟周期数
<font color="red">程序总时钟周期数 = 程序总指令条数 × CPI</font>
已知程序中共有n种不同类型的指令，第i种指令的条数和CPI分别为C<sub>i</sub>和CPI<sub>i</sub>，则：
$$
程序总时钟周期数 = \sum_{i = 1}^{n}(CPI_{i} × C_{i})
$$
程序的综合CPI可由如下公式求得，其中F<sub>i</sub>表示第i种指令在程序中所占的比例
$$
CPI = \sum_{i = 1}^{n}(CPI_{i}×F_{i}) = \frac{程序总时钟周期数} {程序总指令条数}
$$
若已知程序综合CPI和总指令条数，则可使用如下公式计算用户的CPU时间
<font color="red">用户CPU时间 = CPI × 程序总指令条数 × 时钟周期</font></p> <p><strong>CPU执行时间的计算</strong>
下方的（CPU时钟周期数/程序表示的是每个程序的CPU时钟周期数，指令条数/程序表示每个程序的指令条数）
<font color="red">CPU执行时间 = CPU时钟周期数 / 程序 × 时钟周期</font> <font color="red">= CPU时钟周期数 / 程序 ÷ 时钟频率</font> <font color="red">= 指令条数 / 程序 × CPI</font></p> <p><font color="red">CPU时钟周期数 / 程序 = 指令条数 / 程序 × CPI</font> <font color="red">CPI = CPU时钟周期数 / 程序 ÷ 指令条数 / 程序</font></p> <blockquote><p>问题：指令的CPI、机器的CPI、程序的CPI各能反映哪方面的性能？单靠CPI不能反映CPU性能！为什么？
例如，单周期处理器CPI = 1，但性能差！因为单周期处理器在执行指令时需要花费很长时间，而且不能同时执行多个指令。相比之下，流水线处理器的CPI可能会高一些，但它可以同时执行多个指令，因此能够提高计算机处理器的效率和性能。因此，在比较计算机处理器的性能时，需要综合考虑多个因素，而不仅仅是CPI</p></blockquote> <p><font color="red">Example1</font></p> <blockquote><p>程序P在机器A上运行需10s，机器A的时钟频率为400MHz。现在要设计一台机器B，希望该程序在B上运行只需6s。机器B时钟频率的提高导致了其CPI的增加，使得程序P在机器B上时钟周期数是在机器A上的1.2倍。机器B的时钟频率达到A的多少倍才能使程序P在B上执行速度是A上的10/6=1.67倍？</p> <p>答：$$CPU时间A = \frac{时钟周期数A}{时钟频率A}$$
$$CPU时间B = \frac{时钟周期数B}{时钟频率B}$$
由题：时钟周期数B = 1.2时钟周期A，CPU时间A = 10s，CPU时间B = 6s，带入解得：时钟频率B = 800MHz
<font color="red">机器B的时钟频率是A的两倍，但机器B的速度并不是A的两倍！</font></p></blockquote> <blockquote><p>例1.1 假设某个频繁使用的程序P在机器M1上运行需要10s，M1的时钟频率为2GHz。设计人员想开发一台与M1具有相同ISA的新机器M2。采用新技术可使M2的时钟频率增加，但同时也会使CPI增加。假定程序P在M2上的时钟周期数是在M1上的1.5倍，则M2的时钟频率至少要达到多少才能使程序P在M2上的运行时间缩短为6s？</p> <p>答：$$CPU时间M_{1} = \frac{时钟周期M_{1}}{时钟频率M_{1}}$$
$$CPU时间M_{2} = \frac{时钟周期M_{2}}{时钟频率M_{2}}$$
由题：CPU时间M1 = 10s，CPU时间M2 = 6s，时钟周期M2 = 1.5时钟周期M1，时钟频率M1 = 2GHz，带入解得：时钟频率M2 = 5GHz</p></blockquote> <p><strong>选择性能评价程序</strong></p> <ul><li><font color="red">用基准程序来评测计算机的性能</font> <ul><li>基准程序是专门用来进行性能评价的一组程序</li> <li>最好的基准程序是用户实际使用的程序或典型的简单程序</li></ul></li> <li><font color="red">基准程序的缺陷</font> <ul><li>现象：基准程序的性能与某段短代码密切相关时，会被利用以得达到不当的性能评测结果</li> <li>手段：硬件系统设计人员或编译器开发者针对这些代码片段进行特殊优化，使得执行这段代码的速度非常快</li></ul></li></ul> <p><strong>Amdahl定律</strong></p> <ul><li>阿姆达尔定律是计算机系统设计方面重要的定量原则之一
<ul><li>基本思想：对系统中某部分（硬件或软件）进行更新所带来的系统性能改进程度，取决于该部分被使用的频率或其执行时间占总执行时间的比例。
$$
改进后的执行时间 = \frac{改进部分执行时间}{改进部分的改进倍数} + 未改进部分执行时间
$$
或
$$
整体改进倍数 = \frac{1}{\frac{改进部分时间比例}{改进部分的改进倍数} + 未改进部分时间比例}
$$</li></ul></li></ul> <blockquote><p>问题：若整数乘法器改进后可加快10倍，整数乘法指令在程序中占40%，则整体性能可改进多少倍？若占比达60%和90%，则整体性能分别能改进多少倍？</p></blockquote> <p>答：假设原来的整数乘法执行的时间是 $T_{mul}$，其他部分执行的时间是 $T_{other}$。则程序的总执行时间是 $T = T_{mul} + T_{other}$。我们可以先计算占比对应的时间。由于整数乘法指令在程序中占40%，那么： $$ T_{mul} = 0.4 T, \quad T_{other} = 0.6 T $$ 在改进后，整数乘法器加快了10倍，所以新的整数乘法执行时间是： $$ T'<em>{mul} = T</em>{mul}/10 = 0.04 T $$ 新的程序总执行时间是: $$ T' = T'<em>{mul} + T</em>{other} = 0.04T + 0.6T = 0.64T $$ 那么整体性能的改进倍数： $$ \frac{T}{T'} = \frac{T}{0.64T} = \frac{1}{0.64} \approx 1.56 $$ 当整数乘法指令的占比分别达到60%和90%时，我们可以用类似的方法进行计算。这里我们用一个通用公式表示这个过程，令$x$表示整数乘法器在程序中的占比： $$ \frac{T}{T'} = \frac{1}{(1-x)+\frac{x}{10}} $$ 当整数乘法指令的占比达到60%，即 $x = 0.6$时： $$ \frac{T}{T'} = \frac{1}{(1-0.6)+\frac{0.6}{10}} = \frac{1}{0.46} \approx 2.17 $$ 当整数乘法指令的占比达到90%，即 $x = 0.9$时： $$ \frac{T}{T'} = \frac{1}{(1-0.9)+\frac{0.9}{10}} = \frac{1}{0.19} \approx 5.26 $$ 所以当整数乘法指令的占比分别达到60%和90%时，整体性能分别能改进2.17倍和5.26倍。</p> <blockquote><p>例：某程序在某台计算机上运行所需时间是100s，其中，80s用来执行乘法操作。要使该程序的性能是原来的5倍，若不改进其他部件而仅改进乘法部件，则乘法部件的速度应该提高到原来的多少倍？</p> <p>答：根据公式$$p = \frac{1}{\frac{t}{n} + 1-t}$$知：$$5 = \frac{1}{\frac{0.8}{n} + 0.2}$$$$\frac{0.8}{n} + 0.2 = \frac{1}{5} = 0.2$$
要使上述公式满足，必须$$\frac{0.8}{n} = 0，即n\to \infty$$</p></blockquote> <h1 id="第二章-数据的机器级表示与处理"><a href="#第二章-数据的机器级表示与处理" class="header-anchor">#</a> 第二章 数据的机器级表示与处理</h1> <h2 id="数值数据的表示"><a href="#数值数据的表示" class="header-anchor">#</a> 数值数据的表示</h2> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306102106166.png" alt="image.png"></p> <h3 id="信息的二进制编码"><a href="#信息的二进制编码" class="header-anchor">#</a> 信息的二进制编码</h3> <ul><li>机器级数据分为两大类
<ul><li>数值数据：无符号整数、带符号整数、浮点数（实数）</li> <li>非数值数据：逻辑数（包括位串）、西文字符和汉字</li></ul></li> <li>计算机内部所有信息都用二进制（即0和1）进行编码</li> <li>用二进制编码的原因
<ul><li>制造二个稳定态的物理器件容易（电位高/低，脉冲有/无，正/负极）</li> <li>二进制编码、计数、运算规则简单</li> <li>正好与逻辑命题真/假对应，便于逻辑运算</li> <li>可方便地用逻辑电路实现算术运算</li></ul></li> <li>真值和机器数（<font color="red">非常重要的概念！</font>）
<ul><li><font color="blue">机器数：用0和1编码的计算机内部的0/1序列</font></li> <li><font color="blue">真值：真正的值，即：现实中带正负号的数</font></li> <li>例如：usigned short类型变量x的真值是127,其机器数是多少？
127 = 2<sup>7</sup>-1，其机器数为0000 0000 0001 1111</li></ul></li></ul> <h3 id="数值数据的表示-2"><a href="#数值数据的表示-2" class="header-anchor">#</a> 数值数据的表示</h3> <ul><li>数值数据表示的三要素
<ul><li>进位计数制</li> <li>定、浮点表示</li> <li>如何用二进制编码</li> <li>即：要确定一个数值数据的值必须要确定这三个元素。例如：20137564的值是多少？答案是不知道！</li></ul></li> <li>进位计数制
<ul><li>十进制、二进制（<font color="red">通常后缀“B”表示二进制数，如01011010B</font>）、十六进制（<font color="red">后缀H或者前缀0x表示</font>）、八进制数（<font color="red">后缀O表示</font>）及其相互转换</li></ul></li> <li>定/浮点表示（<font color="green">解决</font><font color="red">小数点</font><font color="green">问题</font>）
<ul><li>定点整数、定点小数</li> <li>浮点数（可用一个定点小数和一个定点整数来表示）</li></ul></li> <li>定点数的编码（<font color="green">解决</font><font color="red">正负号</font><font color="green">问题</font>）
<ul><li>源码、补码、反码、移码（反码很少用）</li></ul></li> <li><font color="red">现代计算机系统多用</font><font color="green">十六进制</font><font color="red">表示</font><font color="green">机器数</font></li></ul> <h3 id="十进制数与r进制数之间的转换"><a href="#十进制数与r进制数之间的转换" class="header-anchor">#</a> 十进制数与R进制数之间的转换</h3> <p><font color="blue">（1）R进制数 =&gt; 十进制数</font> <font color="orange">按“权”展开</font> <font color="green">例1：(10101.01)<sub>2</sub> = 1×2<sup>4</sup> + 1×2<sup>2</sup> + 1×2<sup>0</sup> + 1×2<sup>-2</sup> = (21.25)<sub>10</sub></font> <font color="green">例2：(307.6)<sub>8</sub> = 3×8<sup>2</sup> + 7×8<sup>0</sup> + 6×8<sup>-1</sup> = (199.75)<sub>10</sub></font> <font color="green">例3：(3A.1)<sub>16</sub> = 3×16<sup>1</sup> + 10×16<sup>0</sup> + 1×16<sup>-1</sup> = (58.0625)<sub>10</sub></font></p> <p><font color="blue">（2）十进制数 =&gt; 二进制数</font> <font color="orange">整数部分和小数部分分别转换</font> <font color="red">1. 整数——— “除基取余，上右下左”</font> <font color="red">2. 小数——— “乘基取整，上左下右”</font></p> <blockquote><p>将十进制整数和小数一起转换为二进制时，需要分别处理整数部分和小数部分，然后按照顺序将它们放在一起。</p> <p>整数部分，使用除以2法来分而治之。例如：将1转换为二进制：1 ÷ 2 商是0，余数是1，整数部分的二进制表示为1</p> <p>小数部分，通过连续乘以2的方式将十进制小数转为二进制小数。例如：1.23中的小数部分为0.23：
0.23 × 2 = 0.46（整数部分为0）
0.46 × 2 = 0.92（整数部分为0）
0.92 × 2 = 1.84（整数部分为1）
0.84 × 2 = 1.68（整数部分为1）
0.68 × 2 = 1.36（整数部分为1）
可以继续此过程获得更多的二进制位。这里只显示前5位，将整数部分按顺序排列，为二进制小数0.00111。整数1和小数0.00111相结合，得到1.23的二进制表示为1.00111。</p> <p>在将十进制小数转为二进制小数时，通过乘以2来执行转换。何时结束取决于几个因素：</p> <ol><li>期望精度：如果想要获得特定数量的二进制小数位，例如5位或10位，则可执行相应的步骤数并在此处停止</li> <li>重复模式：在某些情况下，通过小数部分乘以2，结果中的整数部分将开始重复出现相同的模式。在这种情况下，可以得出结论，已找到无限重复的二进制小数表示。例如，十进制数0.1的二进制无线循环表示为0.0001100110011...；在看到重复的模式“0011”时，可以停止。</li> <li>结果为0：对于某些十进制小数，通过乘以2的足够次数，结果的小数部分将变为0。这意味着已找到一个精确的二进制表示，不在需要执行任何进一步的步骤</li></ol></blockquote> <p><span style="color:#ff0000;">现实中都精确值可能在机器内部无法使用0和1精确表示！
</span></p> <h3 id="定点数和浮点数"><a href="#定点数和浮点数" class="header-anchor">#</a> 定点数和浮点数</h3> <ul><li><span style="color:#1100fa;">计算机中只能通过</span><span style="color:#ff0000;">约定小数点都位置</span><span style="color:#1100fa;">来表示小数点</span> <ul><li>小数点位置约定在固定位置的数称为<span style="color:#ff0000;">定点数</span></li> <li>小数点位置约定为可浮动的数称为<span style="color:#ff0000;">浮点数</span></li></ul></li> <li><span style="color:#ff0000;">定点小数</span>用来表示浮点数的尾数部分</li> <li><span style="color:#ff0000;">定点整数</span>用来表示整数，分<span style="color:#ff0000;">带符号整数</span>和<span style="color:#ff0000;">无符号整数</span></li> <li>任何实数：X = (-1)<sup>s</sup> × M × R<sup>E</sup>
其中，S取值为0或1,用来决定数<span style="color:#ff0000;">X的符号；M是一个二进制定点小数</span>，称为数<span style="color:#ff0000;">X的尾数</span>；<span style="color:#ff0000;">E是一个二进制点整数</span>，称为数<span style="color:#ff0000;">X的阶或指数</span>；R是<span style="color:#ff0000;">基数</span>，可以为2、4和16等。计算机中只要表示S、M和E三个信息，就能确定X的值，这称为<span style="color:#ff0000;">浮点数</span></li></ul> <h3 id="原码表示"><a href="#原码表示" class="header-anchor">#</a> 原码表示</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306152143900.png" alt="image.png"></p> <p><span style="color:#ff0000;">“正”号用0表示</span> <span style="color:#ff0000;">“负号”用1表示</span> <span style="color:#ff0000;">数值部分不变！</span></p> <ul><li>容易理解，但是：
<ul><li>0的表示不唯一，故不利于程序员编程</li> <li>加、减运算方式不统一</li> <li>需额外对符号位进行处理，故不利于硬件设计</li> <li>特别当a &lt; b时，实现a - b比较困难
<span style="color:#ff0000;">从50年代开始，整数都采用补码来表示，但浮点数的尾数用原码定点小数表示</span></li></ul></li></ul> <h3 id="移码"><a href="#移码" class="header-anchor">#</a> 移码</h3> <ul><li>什么是移码表示？
<ul><li><span style="color:#ff0000;">将每一个数值加上一个偏置常数</span></li></ul></li> <li>通常，当编码位数为<span style="color:#ff0000;">n</span>时，偏执常数取<span style="color:#ff0000;">2<sup>n-1</sup></span>或<span style="color:#ff0000;">2<sup>n-1</sup>-1</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306152209634.png" alt="image.png"></li> <li>为什么要用移码来表示指数（阶码）？
<span style="color:#ff0000;">便于浮点数加减运算时的对阶操作（比较大小）</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306152212299.png" alt="image.png"></li></ul> <h3 id="补码"><a href="#补码" class="header-anchor">#</a> 补码</h3> <p>重要概念：<span style="color:#ff0000;">在一个模运算系统中，一个数与它除以“模”后的余数等价</span>
时钟是一种模12系统     <span style="color:#ff0000;">现实生活中的模运算系统</span></p> <p><span style="color:#1100fa;">假定钟表时钟指向10点，要将它拨向6点，则有两种拨法：</span> <span style="color:#1100fa;">①倒拨4格：10 - 4 = 6</span> <span style="color:#1100fa;">②顺拨8格：10 + 8 = 18 == 6  (mod 12)</span> <span style="color:#1100fa;">模12系统中：10 - 4 = 10 + 8 (mod 12)<br>-4 = 8 (mod 12)</span> <span style="color:#1100fa;">则，称8是-4对12的补码</span><span style="color:#ff0000;">（即：-4的模12补码等于8）</span> <span style="color:#1100fa;">同样有 -3 == 9 (mod 12)<br>-5 == 7 (mod 12)等</span></p> <p>结论1：<span style="color:#ff0000;">一个负数的补码等于模减去该负数的绝对值</span>
结论2：<span style="color:#ff0000;">对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替</span></p> <p><span style="color:#ff0000;">补码（mod运算）：实现了+和-的统一</span></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306152247476.png" alt="image.png"></p> <p><mark style="background:#FF5582A6;">计算机中的运算器是模运算系统</mark> <span style="color:#ff0000;">8位二进制加法模运算系统</span></p> <blockquote><p>计算 0111 1111 - 0100 0000 = ？
[-0100 0000]<sub>补</sub> = 1100 0000
0111 1111 - 0100 0000 = 0111 1111 + [-0100 0000]<sub>补</sub>
= 0111 1111 + 1100 0000 = 0011 1111</p></blockquote> <ul><li>结论1：<span style="color:#ff0000;">一个负数的补码等于对应正数补码的“各位取反，末位加1”</span></li></ul> <blockquote><p>在一个4位的运算器中，最高位是符号位，表示正数或负数。当最高位为0时，表示一个正数；当最高位为1时，表示一个负数。</p></blockquote> <p>对于正数的表示，可以使用0到7这8个非负整数。因为最高位为0，所以可以得到以下数值：
0000 -&gt; 0
0001 -&gt; 1
0010 -&gt; 2
0011 -&gt; 3
0100 -&gt; 4
0101 -&gt; 5
0110 -&gt; 6
0111 -&gt; 7
对于负数的表示，可以使用8到15这8个整数，但在二进制补码表示中，负数的真值是通过将其对应正数的补码取反加1来获得。因此，负数的表示如下：
1000 -&gt; -8
1001 -&gt; -7
1010 -&gt; -6
1011 -&gt; -5
1100 -&gt; -4
1101 -&gt; -3
1110 -&gt; -2
1111 -&gt; -1
因此，对于一个4位的运算器，真值范围为-8到7。</p> <p>补码的定义    假定补码有n位，则：
<span style="color:#ff0000;">[X]<sub>补</sub> = 2<sup>n</sup> + X  (-2<sup>n</sup> &lt;= X &lt;= 2<sup>n</sup>，mod 2<sup>n</sup>)</span>
X是真值，[X]<sub>补</sub>是机器数</p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306161441740.png" alt="image.png"></p> <h4 id="求特殊数的补码"><a href="#求特殊数的补码" class="header-anchor">#</a> 求特殊数的补码</h4> <p>假定机器数有n位
<span style="color:#ff0000;">①[-2<sup>n-1</sup>]<sub>补</sub> = 2<sup>n</sup> - 2<sup>n-1</sup> = 10...0（n - 1个0）    (mod 2<sup>n</sup>)</span> <span style="color:#ff0000;">②[-1]<sub>补</sub> = 2<sup>n</sup> - 0...01 = 11...1（n个1）  (mod 2<sup>n</sup>)</span> <span style="color:#ff0000;">③[+0]<sub>补</sub> = [-0]<sub>补</sub> = 00...0（n个0）</span></p> <p>32位机器中，int、short、char型数据机器数各占<span style="color:#ff0000;">32位、16位、8位</span></p> <h4 id="补码与真值之间的简便转换"><a href="#补码与真值之间的简便转换" class="header-anchor">#</a> 补码与真值之间的简便转换</h4> <p><span style="color:#ff0000;">注：正数的补码是其本身，负数的补码是其对应正数补码的“各位取反，末位加一”</span></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/202306161512796.png" alt="image.png"></p> <h4 id="求补码的真值"><a href="#求补码的真值" class="header-anchor">#</a> 求补码的真值</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161534911.png" alt="image.png"></p> <h3 id="无符号整数和带符号整数"><a href="#无符号整数和带符号整数" class="header-anchor">#</a> 无符号整数和带符号整数</h3> <p><span style="color:#ff0000;">整数类型分：无符号整数和带符号整数</span></p> <h4 id="无符号整数-unsigned-integer"><a href="#无符号整数-unsigned-integer" class="header-anchor">#</a> 无符号整数（Unsigned integer）</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161541291.png" alt="image.png"> <span style="color:#ff0000;">一般来说，计算机中采用高到低位从左到右的方式</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161545360.png" alt="image.png"></p> <ul><li>无符号整数的编码中<span style="color:#ff0000;">没有符号位</span></li> <li>能表示的最大值大于位数相同的带符号整数的最大值（Why？）
<ul><li>例如：8位无符号整数最大是255（1111 1111），而带符号整数最大是127（0111 1111）</li></ul></li> <li>总是整数，所以很多时候就<span style="color:#ff0000;">简称为“无符号数”</span></li></ul> <h4 id="带符号整数-定点整数-signed-integer"><a href="#带符号整数-定点整数-signed-integer" class="header-anchor">#</a> 带符号整数，定点整数（Signed integer）</h4> <ul><li>计算机必须能处理正数和负数，MSB表示数符</li> <li>有三种定点编码方式
<ul><li>原码
<ul><li><span style="color:#ff0000;">现用来表示浮点（实）数的尾数</span></li></ul></li> <li>反码
<ul><li><span style="color:#ff0000;">现已不用于表示数值数据</span></li></ul></li> <li>补码
<ul><li><span style="color:#ff0000;">50年代以来，所有计算机都用补码表示定点整数</span></li></ul></li></ul></li> <li>为什么用补码表示带符号整数？
<ul><li><span style="color:#1100fa;">补码运算系统是模运算系统，加、减运算统一</span></li> <li><span style="color:#1100fa;">数0的表示唯一，方便使用</span></li> <li><span style="color:#1100fa;">比原码和反码多表示一个最小负数</span></li></ul></li></ul> <h4 id="c语言程序中的整数"><a href="#c语言程序中的整数" class="header-anchor">#</a> C语言程序中的整数</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161612377.png" alt="image.png"> <span style="color:#ff0000;">C语言标准规定：若运算中同时有无符号和带符号整数，则按无符号整数运算</span></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161619024.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161623360.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161636815.png" alt="image.png"></p> <h3 id="浮点数"><a href="#浮点数" class="header-anchor">#</a> 浮点数</h3> <p><span style="color:#ff0000;">实数类型分：单精度浮点、浮点双精度和扩展精度浮点</span></p> <h4 id="科学计数法与浮点数"><a href="#科学计数法与浮点数" class="header-anchor">#</a> 科学计数法与浮点数</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306161659543.png" alt="image.png"></p> <h4 id="浮点数表示范围"><a href="#浮点数表示范围" class="header-anchor">#</a> 浮点数表示范围</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617103426.png" alt="image.png">
最大正数：0.11...1 × 2<sup>11...1</sup> = (1 - 2<sup>-24</sup>) × 2<sup>127</sup>
最小正数：0.10...0 × 2<sup>00...0</sup> = (1/2) × 2<sup>-128</sup>
偏执常数128 + x = 11...1(255)  x = 127
偏执常数128 + x = 00...0(0)  x = -128</p> <p>因为原码是对称的，所以其表示范围关于原点对称
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617104407.png" alt="image.png">
机器0：位数为0 或 落在下溢区中的数
浮点数范围比定点数大，但数的个数没变多，故数之间更稀疏，且不均匀</p> <h4 id="ieee-754标准"><a href="#ieee-754标准" class="header-anchor">#</a> IEEE 754标准</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617110515.png" alt="image.png">
偏执常数127 + x = 0000 0001(1)   x = -126
偏执常数127 + x = 1111 1110(254)  x = 127
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617110324.png" alt="image.png">
SP(单精度浮点型)：(-1)<sup>符号位</sup> × (1 + 尾数) × 2<sup>(阶码 - 偏执常数(127))</sup>
DP(双精度浮点型)：(-1)<sup>符号位</sup> × (1 + 尾数) × 2<sup>(阶码 - 偏执常数(1023))</sup></p> <h4 id="举例-机器数转换为真值"><a href="#举例-机器数转换为真值" class="header-anchor">#</a> 举例：机器数转换为真值</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617112616.png" alt="image.png"></p> <h4 id="举例-真值转换为机器数"><a href="#举例-真值转换为机器数" class="header-anchor">#</a> 举例：真值转换为机器数</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617113044.png" alt="image.png"></p> <h4 id="_0机器数表示"><a href="#_0机器数表示" class="header-anchor">#</a> 0机器数表示</h4> <p>阶码：全0
尾数：全0</p> <p>+0: 0 00000000 00000000000000000000000
-0: 1 00000000 00000000000000000000000</p> <h4 id="∞-∞的机器数表示"><a href="#∞-∞的机器数表示" class="header-anchor">#</a> +∞/-∞的机器数表示</h4> <p>浮点数除0的结果是+∞/-∞，不是溢出异常。（整数除0为异常）
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617204551.png" alt="image.png">
阶码：全1(11111111B = 255)
尾数：全0
+∞ = 0 11111111 00000000000000000000000
-∞ = 1 11111111 00000000000000000000000</p> <p>相关操作：
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617204747.png" alt="image.png"></p> <h4 id="非数-的表示"><a href="#非数-的表示" class="header-anchor">#</a> “非数”的表示</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617205240.png" alt="image.png">
阶码：全1(11111111B = 255)
尾数：非0
NaNS可以帮助调试程序
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617205517.png" alt="image.png"></p> <h4 id="非规格化数的表示"><a href="#非规格化数的表示" class="header-anchor">#</a> 非规格化数的表示</h4> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617210713.png" alt="image.png"></p> <h2 id="第一讲小节"><a href="#第一讲小节" class="header-anchor">#</a> 第一讲小节</h2> <ul><li>在机器内部编码后的数称为机器数，其值称为真值</li> <li>定义数值的三个要素：进制、定点/浮点、编码</li> <li>整数的表示
<ul><li>无符号数：正整数，用来表示地址等</li> <li>带符号数：用补码表示</li></ul></li> <li>C语言中的整数：
<ul><li>无符号数：unsigned int(short/long)</li> <li>带符号数：int(short/long)</li></ul></li> <li>浮点数的表示
<ul><li>符号</li> <li>尾数：定点小数</li> <li>指数（阶）：定点整数（基不用表示）</li></ul></li> <li>浮点数的范围：
<ul><li>正上溢</li> <li>正下溢</li> <li>负上溢</li> <li>负下溢</li> <li>与阶码的位数和基的大小有关</li></ul></li> <li>浮点数的精度：与尾数的尾数和是否规格化有关</li> <li>浮点数的表示（IEEE 754标准）：单精度SP(float)和双精度DP(double)
<ul><li>规格化数(SP)：阶码1~254，尾数最高位隐含1</li> <li>“零”（阶码全0，尾数全0）</li> <li>∞（阶码全1，尾数全0）</li> <li>NaN（阶码全1，尾数非0）</li> <li>非规格化数（阶码全0，尾数非0，隐含位为0）</li></ul></li> <li>十进制数的表示：用ASCII码或BCD码表示</li></ul> <h2 id="非数值数据的表示、数据的存储"><a href="#非数值数据的表示、数据的存储" class="header-anchor">#</a> 非数值数据的表示、数据的存储</h2> <h3 id="数据的基本宽度"><a href="#数据的基本宽度" class="header-anchor">#</a> 数据的基本宽度</h3> <ul><li>比特（bit）是计算机中处理、存储、传输信息的最小单位</li> <li>二进制信息最基本的计量单位是“字节”（Byte），也称“位组”
<ul><li>现代计算机中，存储器按字节编址</li> <li>字节是最小可寻址单位</li> <li>如果以字节为一个排列单位，则LSB表示最低有效字节，MSB表示最高有效字节</li></ul></li> <li>除比特和字节外，还经常考虑使用“字”作为单位</li> <li>“字”和“字长”的概念不同
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617214448.png" alt="image.png"></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617214659.png" alt="image.png"></p> <h3 id="数据量的度量单位"><a href="#数据量的度量单位" class="header-anchor">#</a> 数据量的度量单位</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617214941.png" alt="image.png"></p> <h3 id="程序中数据类型的宽度"><a href="#程序中数据类型的宽度" class="header-anchor">#</a> 程序中数据类型的宽度</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617215227.png" alt="image.png"></p> <h3 id="数据的存储和排列顺序"><a href="#数据的存储和排列顺序" class="header-anchor">#</a> 数据的存储和排列顺序</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617231452.png" alt="image.png">
小端：低位放低地址，高位放高地址
大端：高位放低地址，低位放高地址</p> <h3 id="大端-小端方式举例"><a href="#大端-小端方式举例" class="header-anchor">#</a> 大端/小端方式举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617232231.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617233937.png" alt="image.png"></p> <h3 id="字节交换问题"><a href="#字节交换问题" class="header-anchor">#</a> 字节交换问题</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617234604.png" alt="image.png"></p> <h3 id="c表达式类型转换顺序"><a href="#c表达式类型转换顺序" class="header-anchor">#</a> C表达式类型转换顺序</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230617235309.png" alt="image.png"></p> <h2 id="第二讲小结"><a href="#第二讲小结" class="header-anchor">#</a> 第二讲小结</h2> <ul><li>数据的宽度
<ul><li>位、字节、字（不一定等于字节）</li> <li>k / K / M / G / T / P / E / Z / Y 有不同的含义</li></ul></li> <li>数据的存储排列
<ul><li>数据的地址：连续若干单元中最小的地址，即：从小地址开始存放数据</li> <li>大端方式：用MSB存放的地址表示数据地址</li> <li>小端方式：用LSB存放的地址表示数据地址</li> <li>按边界对齐可减少访存次数</li></ul></li></ul> <h2 id="数据的运算"><a href="#数据的运算" class="header-anchor">#</a> 数据的运算</h2> <h3 id="c语言程序中涉及的运算"><a href="#c语言程序中涉及的运算" class="header-anchor">#</a> C语言程序中涉及的运算</h3> <ul><li>算术运算（最基本的运算）
<ul><li><span style="color:#1100fa;">无符号数、带符号数、浮点数的+、-、*、/运算等</span></li></ul></li> <li>按位运算
<ul><li><span style="color:#1100fa;">用途</span> <ul><li>对位串实现“掩码”操作或相应的其他处理（主要用于对多媒体数据或状态/控制信息进行处理）</li></ul></li> <li><span style="color:#1100fa;">操作</span> <ul><li>按位或：“|”</li> <li>按位与：“&amp;”</li> <li>按位取反：“~”</li> <li>按位异或：“^”</li></ul></li></ul></li> <li>逻辑运算
<ul><li><span style="color:#1100fa;">用途</span> <ul><li>用于关系表达式的运算</li></ul></li> <li><span style="color:#1100fa;">操作</span> <ul><li>“||”表示“OR”运算</li> <li>“&amp;&amp;”表示“AND”运算</li> <li>“!”表示“NOT”运算</li></ul></li> <li><span style="color:#1100fa;">与按位运算的差别</span> <ul><li>符号表示不同：&amp;对&amp;&amp;；|对||</li> <li>运算过程不同：按位对整体</li> <li>结果类型不同：位串对逻辑值</li></ul></li></ul></li> <li>移位运算
<ul><li><span style="color:#1100fa;">用途</span> <ul><li>提取部分信息</li> <li><span style="color:#01460f;">扩大或缩小数值的2、4、8...倍</span></li></ul></li> <li><span style="color:#1100fa;">操作</span> <ul><li><span style="color:#01460f;">左移：x &lt;&lt; k；右移：x &gt;&gt; k</span></li> <li>C语言中不区分是逻辑还是算术位移，编译器<span style="color:#01460f;">根据x的类型确定</span></li> <li><span style="color:#01460f;">无符号数：逻辑左移、逻辑右移</span> <ul><li><span style="color:#ff0000;">高（低）位移出，低（高）位补0，可能溢出！</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230618105431.png" alt="image.png"></li></ul></li> <li><span style="color:#01460f;">带符号数：算术左移、算术右移</span> <ul><li><span style="color:#ff0000;">左移：高位移除，低位补0。可能溢出！</span> <ul><li><span style="color:#fa7900;">溢出判断：若移除的位不等于新的符号位，则溢出</span></li></ul></li> <li><span style="color:#ff0000;">右移：低位移除，高位补符，可能发生有效数据丢失</span></li></ul></li></ul></li></ul></li> <li>位扩展和位截断运算
<ul><li><span style="color:#1100fa;">用途</span> <ul><li><span style="color:#01460f;">类型转换时可能需要数据扩展或截断</span></li></ul></li> <li><span style="color:#1100fa;">操作</span> <ul><li>C语言中没有专门操作运算符，编译器<span style="color:#01460f;">根据类型转换前后数据的长短，确定是扩展还是截断</span></li> <li><span style="color:#01460f;">扩展：长转短</span> <ul><li><span style="color:#ff0000;">无符号数：0扩展，前面补0</span></li> <li><span style="color:#ff0000;">带符号整数：符号扩展，前面补符</span></li></ul></li> <li><span style="color:#01460f;">截断：长转短</span> <ul><li><span style="color:#ff0000;">强行将高位丢弃，故可能发生“溢出”</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230618110322.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230618110515.png" alt="image.png"></li></ul></li></ul></li></ul></li></ul> <h3 id="n位整数加-减运算器"><a href="#n位整数加-减运算器" class="header-anchor">#</a> n位整数加/减运算器</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181330549.png" alt="image.png"></p> <ul><li>补码加减运算公式
<span style="color:#1100fa;">[A + B]<sub>补</sub> = [A]<sub>补</sub> + [B]<sub>补</sub>   (mod 2<sup>n</sup>)</span> <span style="color:#1100fa;">[A - B]<sub>补</sub> = [A]<sub>补</sub> + [-B]<sub>补</sub>   (mod 2<sup>n</sup>)</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181335185.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181336033.png" alt="image.png"></li></ul> <h3 id="算术逻辑部件alu"><a href="#算术逻辑部件alu" class="header-anchor">#</a> 算术逻辑部件ALU</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181339693.png" alt="image.png"></p> <h3 id="所有运算电路的核心"><a href="#所有运算电路的核心" class="header-anchor">#</a> 所有运算电路的核心</h3> <p><span style="color:#ff0000;">重要认识1：</span><span style="color:#01460f;">计算机中所有算术运算都基于加法器实现！</span> <span style="color:#ff0000;">重要认识2：</span><span style="color:#01460f;">加法器不知道所运算的是带符号数还是无符号数</span> <span style="color:#ff0000;">重要认识3：</span><span style="color:#01460f;">加法器不判断对错，总是取低n位作为结果，并生成标志信息</span></p> <p><span style="color:#1100fa;">当Sub为1时，做减法</span> <span style="color:#1100fa;">当Sub为0时，做加法</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181450223.png" alt="image.png"></p> <h3 id="条件标志位-条件码cc"><a href="#条件标志位-条件码cc" class="header-anchor">#</a> 条件标志位（条件码CC）</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181459343.png" alt="image.png"> <span style="color:#ff0000;">OF：若A与B'同号但与Sum不同号，则为1；否则为0</span> <span style="color:#ff0000;">ZF：若Sum为0，则为1，否则为0</span> <span style="color:#ff0000;">SF：Sum符号</span> <span style="color:#ff0000;">CF：Cout⊕sub</span></p> <ul><li>零标志ZF、溢出标志OF，进/借位标志CF、符号标志SF称为条件标志</li> <li>条件标志在运算电路中产生，被记录到专门的寄存器中</li> <li>存放标志的寄存器通常称为<span style="color:#ff0000;">程序/状态字寄存器或标志寄存器</span>。每个标志对应标志寄存器的一个标志位。</li></ul> <h3 id="n位带标志加法器"><a href="#n位带标志加法器" class="header-anchor">#</a> n位带标志加法器</h3> <ul><li>n位加法器无法用于两个n位<span style="color:#1100fa;">带符号整数</span>（补码）相加，无法<span style="color:#1100fa;">判断是否溢出</span></li> <li>程序中经常需要比较大小，通过（在加法器中）做减法得到的标志信息来判断
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181536390.png" alt="image.png"> <span style="color:#ff0000;">溢出标志OF：C<sub>n</sub>⊕C<sub>n-1</sub></span> <span style="color:#ff0000;">符号标志SF：SF = F<sub>n-1</sub></span> <span style="color:#ff0000;">零标志ZF = 1当且仅当F = 0</span> <span style="color:#ff0000;">进位/借位标志CF：CF = Cout⊕Sub</span>
Cout表示上一位的进位</li></ul> <h3 id="整数加法举例-判溢出"><a href="#整数加法举例-判溢出" class="header-anchor">#</a> 整数加法举例：判溢出</h3> <p>做加法时，主要判断是否溢出
<span style="color:#ff0000;">无符号加溢出条件：CF = 1</span> <span style="color:#ff0000;">带符号加溢出条件：OF = 1</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181559109.png" alt="image.png"> <span style="color:#01460f;">两个正数相加，结果为负数，故溢出！即OF = 1</span> <span style="color:#ff0000;">溢出标志OF = 1、零标志ZF = 0、符号标志SF = 1、进位标志CF = 0</span>
无符号：sum = 153，因为CF = 0，故未发生溢出，结果正确！
带符号：sum = -103，因为OF = 1，故发生溢出，结果错误！</p> <h3 id="整数减法举例-判大小"><a href="#整数减法举例-判大小" class="header-anchor">#</a> 整数减法举例：判大小</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181609600.png" alt="image.png">
带符号溢出：</p> <ul><li><span style="color:#1100fa;">最高位和次高位进位不同</span></li> <li><span style="color:#1100fa;">和的符号位和加数的符号位不同</span></li></ul> <p>无符号减溢出：</p> <ul><li><span style="color:#1100fa;">差位负数，即借位CF=1</span></li></ul> <p><span style="color:#01460f;">做减法以比较大小，规则：</span></p> <ul><li><span style="color:#01460f;">无符号：CF = 0时，大于</span></li> <li><span style="color:#01460f;">有符号：OF = SF时，大于</span></li></ul> <h3 id="整数减法举例"><a href="#整数减法举例" class="header-anchor">#</a> 整数减法举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181619006.png" alt="image.png"></p> <h3 id="整数加法举例"><a href="#整数加法举例" class="header-anchor">#</a> 整数加法举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181623057.png" alt="image.png"></p> <h3 id="ieee-754-标准规定的五种异常情况"><a href="#ieee-754-标准规定的五种异常情况" class="header-anchor">#</a> IEEE 754 标准规定的五种异常情况</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181640584.png" alt="image.png"></p> <h3 id="浮点数加-减运算"><a href="#浮点数加-减运算" class="header-anchor">#</a> 浮点数加/减运算</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181646698.png" alt="image.png"></p> <h3 id="浮点数加减法基本要点"><a href="#浮点数加减法基本要点" class="header-anchor">#</a> 浮点数加减法基本要点</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181651664.png" alt="image.png"></p> <h3 id="浮点数加法运算举例"><a href="#浮点数加法运算举例" class="header-anchor">#</a> 浮点数加法运算举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181658517.png" alt="image.png"></p> <h3 id="附加位"><a href="#附加位" class="header-anchor">#</a> 附加位</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181701775.png" alt="image.png"></p> <h3 id="ieee-754的舍入方式的说明"><a href="#ieee-754的舍入方式的说明" class="header-anchor">#</a> IEEE 754的舍入方式的说明</h3> <p>IEEE 754的舍入方式
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181706203.png" alt="image.png"> <span style="color:#1100fa;">（Z1和Z2分别是结果Z的最接近的可表示的左、右两个数）</span> <span style="color:#1100fa;">（1）就近舍入：</span><span style="color:#ff0000;">舍入为最近可表示的数</span> <span style="color:#ff0000;">非中间值：0舍1入</span> <span style="color:#ff0000;">中间值：强迫结果为偶数</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181709509.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181710923.png" alt="image.png"> <span style="color:#1100fa;">（2）朝+∞方向舍入：</span><span style="color:#ff0000;">舍入为Z2（正向舍入）</span> <span style="color:#1100fa;">（3）朝﹣∞方向舍入：</span><span style="color:#ff0000;">舍入为Z1（负向舍入）</span> <span style="color:#1100fa;">（4）朝0方向舍入：</span><span style="color:#ff0000;">截去。正数：取Z1；负数：取Z2</span></p> <h3 id="c语言中的浮点数类型"><a href="#c语言中的浮点数类型" class="header-anchor">#</a> C语言中的浮点数类型</h3> <ul><li>long double类型的长度和格式随编译器和处理器类型的不同而有所不同，IA-32中是80位扩展精度格式</li> <li><span style="color:#ff0000;">从int转换为float时，不会发生溢出，但可能有数据被舍入</span></li> <li><span style="color:#ff0000;">从int或float转换为double时，因为double的有效位数更多，故能保留精确值</span></li> <li><span style="color:#ff0000;">从float或double转换为int时，因为int没有小数部分，所以数据可能会向0方向被截断</span></li></ul> <h3 id="浮点数比较运算举例"><a href="#浮点数比较运算举例" class="header-anchor">#</a> 浮点数比较运算举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181736332.png" alt="image.png"></p> <h3 id="ieee-754的范围和精度"><a href="#ieee-754的范围和精度" class="header-anchor">#</a> IEEE 754的范围和精度</h3> <ul><li>单精度浮点数（float型）的表示范围多大？
<ul><li><span style="color:#1100fa;">最大的数据：+1.11...1 × 2<sup>127</sup>  约+3.4 × 10<sup>38</sup></span></li> <li><span style="color:#1100fa;">双精度浮点数（double型）  约+1.8 × 10<sup>308</sup></span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306181958982.png" alt="image.png"></li></ul></li></ul> <h1 id="第三章-程序的转换与机器级表示"><a href="#第三章-程序的转换与机器级表示" class="header-anchor">#</a> 第三章 程序的转换与机器级表示</h1> <h2 id="程序转换概述"><a href="#程序转换概述" class="header-anchor">#</a> 程序转换概述</h2> <h3 id="机器级指令"><a href="#机器级指令" class="header-anchor">#</a> 机器级指令</h3> <ul><li><span style="color:#ff0000;">机器指令</span>和<span style="color:#ff0000;">汇编指令</span>一一对应，都是机器级指令</li> <li>机器指令是一个0/1序列，由若干<span style="color:#ff0000;">字段</span>组成
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182019590.png" alt="image.png"></li> <li>汇编指令是机器指令的符号表示（<span style="color:#ff0000;">可有不同的格式</span>）
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182020046.png" alt="image.png"> <span style="color:#1100fa;">mov、movb、bx、%bx等都是</span><span style="color:#ff0000;">助记符</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182023296.png" alt="image.png"></li></ul> <h3 id="ia-32支持的数据类型及格式"><a href="#ia-32支持的数据类型及格式" class="header-anchor">#</a> IA-32支持的数据类型及格式</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182052361.png" alt="image.png"></p> <h3 id="高级语言转换为机器代码的过程"><a href="#高级语言转换为机器代码的过程" class="header-anchor">#</a> 高级语言转换为机器代码的过程</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182102725.png" alt="image.png"> <span style="color:#ff0000;">预处理：</span><span style="color:#1100fa;">在高级语言源程序中插入所有用#include命令指定的文件和#define声明指定的宏</span> <span style="color:#ff0000;">编译：</span><span style="color:#1100fa;">将预处理后的源程序文件编译生成相应的汇编语言程序</span> <span style="color:#ff0000;">汇编：</span><span style="color:#1100fa;">由汇编程序将汇编语言源程序文件转换为可重定位的机器语言目标代码文件</span> <span style="color:#ff0000;">链接：</span><span style="color:#1100fa;">由链接器将多个可重定位的机器语言目标文件以及库例程（如printf()库函数）链接起来，生成最终的可执行目标文件</span></p> <h3 id="ia-32的定点寄存器组织"><a href="#ia-32的定点寄存器组织" class="header-anchor">#</a> IA-32的定点寄存器组织</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182109352.png" alt="image.png"></p> <ul><li><span style="color:#ff0000;">8个通用寄存器</span></li> <li><span style="color:#ff0000;">两个专用寄存器</span></li> <li><span style="color:#ff0000;">6个段寄存器</span></li></ul> <h3 id="ia-32的寻址方式"><a href="#ia-32的寻址方式" class="header-anchor">#</a> IA-32的寻址方式</h3> <ul><li>寻址方式
<ul><li><span style="color:#1100fa;">如何根据指令给定信息得到操作数或操作数地址</span></li></ul></li> <li>操作数所在的位置
<ul><li><span style="color:#1100fa;">指令中：立即寻址</span></li> <li><span style="color:#1100fa;">寄存器中：寄存器寻址</span></li> <li><span style="color:#1100fa;">存储单元中（属于存储器操作数，按字节编址）：其他寻址方式</span></li></ul></li> <li>存储器操作数的寻址方式和微处理器的工作模式有关
<ul><li><span style="color:#1100fa;">两种工作模式：实地址模式和保护模式</span></li></ul></li> <li>保护模式
<ul><li><span style="color:#1100fa;">加电后进入，采用虚拟存储管理，多任务情况下隔离、保护</span></li> <li><span style="color:#1100fa;">80286以上微处理器的工作模式</span></li> <li><span style="color:#1100fa;">寻址空间为2<sup>32</sup>B，32位线性地址分段</span><span style="color:#01460f;">（段基址 + 段内偏移量）</span></li></ul></li></ul> <h3 id="保护模式下的寻址方式"><a href="#保护模式下的寻址方式" class="header-anchor">#</a> 保护模式下的寻址方式</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182233986.png" alt="image.png"></p> <h3 id="存储器操作数的寻址方式"><a href="#存储器操作数的寻址方式" class="header-anchor">#</a> 存储器操作数的寻址方式</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306182244559.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230619094213.png" alt="image.png"> <span style="color:#ff0000;">504 + %ebp + 2 × %esi</span> <span style="color:#ff0000;">以字节编址，低对低，高对高，以低地址示数字对齐</span></p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li>IA-32是典型的CISC（复杂指令集计算机）风格ISA
<ul><li><span style="color:#ff0000;">8个通用寄存器（8位，16位，32位）</span></li> <li><span style="color:#ff0000;">2个专用寄存器：EIP（PC）、标志寄存器EFLAGS</span></li> <li><span style="color:#ff0000;">6个段寄存器（间接给出段基址）</span></li> <li><span style="color:#ff0000;">存储器地址空间位4GB，按字节编址，小端方式</span></li> <li><span style="color:#1100fa;">寻址方式</span> <ul><li><span style="color:#ff0000;">立即、寄存器、存储器（SR:[B] + [I]×s + A）（段基址(SR) + 有效地址(偏移量)）</span></li> <li><span style="color:#1100fa;">相对寻址</span></li></ul></li> <li><span style="color:#1100fa;">变长指令字、变成操作码</span></li></ul></li> <li>汇编语言格式
<ul><li>Intel格式汇编</li> <li>AT&amp;T格式汇编</li></ul></li></ul> <h2 id="ia-32指令系统"><a href="#ia-32指令系统" class="header-anchor">#</a> IA-32指令系统</h2> <h3 id="ia-32常用指令类型"><a href="#ia-32常用指令类型" class="header-anchor">#</a> IA-32常用指令类型</h3> <ul><li>传送指令
<ul><li><span style="color:#1100fa;">通用数据传送指令</span> <ul><li><span style="color:#01460f;">MOV：一般传送，包括movb、movw和movl等</span></li> <li><span style="color:#01460f;">MOVS：符号扩展传送，如movsbw、movswl</span></li> <li><span style="color:#01460f;">MOVZ：零扩展传送，如movzwl、movzbl等</span></li> <li><span style="color:#01460f;">XCHG：数据交换</span></li> <li><span style="color:#01460f;">PUSH/POP：入栈/出栈，如pushl，pushw，popl，popw等</span></li></ul></li> <li><span style="color:#1100fa;">地址传送指令</span> <ul><li>LEA：加载有效地址，如&quot;leal(%edx, %eax), %eax&quot;的功能为R[eax]&lt;--R[edx] + R[eax]，执行前，若R[edx] = i，R[eax] = j，则指令执行后，R[eax] = i + j</li></ul></li> <li><span style="color:#1100fa;">输入输出指令</span> <ul><li><span style="color:#01460f;">IN和OUT：I/O端口与寄存器之间的交换</span></li></ul></li> <li><span style="color:#1100fa;">标志传送指令</span> <ul><li><span style="color:#01460f;">PUSHF、POPF：将EFLAG压栈，或将栈顶内容送EFLAG</span></li></ul></li></ul></li></ul> <h3 id="入栈-pushw-ax"><a href="#入栈-pushw-ax" class="header-anchor">#</a> “入栈”（pushw %ax）</h3> <ul><li>栈（Stack）是一种采用<span style="color:#ff0000;">“先进后出”</span>方式进行访问的一块存储区，用于<span style="color:#ff0000;">嵌套过程调用</span>。<span style="color:#ff0000;">从高地址向低地址增长</span></li> <li>“栈”不等于<span style="color:#ff0000;">“堆栈”</span>（堆栈由“堆”和“栈”组成）
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230619105925.png" alt="image.png"> <span style="color:#ff0000;">AL存储低位，AH存储高位，由于栈是由高地址向低地址增长，又是小端方式，故AL在栈顶，AH在栈底</span></li></ul> <h3 id="出栈-popw-ax"><a href="#出栈-popw-ax" class="header-anchor">#</a> “出栈”（popw %ax）</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230619110211.png" alt="image.png"></p> <h3 id="ia-32常用指令类型-2"><a href="#ia-32常用指令类型-2" class="header-anchor">#</a> IA-32常用指令类型</h3> <ul><li>定点算术运算指令
<ul><li><span style="color:#1100fa;">加/减运算（影响标志、不区分无/带符号）</span> <ul><li><span style="color:#01460f;">ADD：加，包括addb、addw、addl等</span></li> <li><span style="color:#01460f;">SUB：减，包括subb、subw、subl等</span></li></ul></li> <li><span style="color:#1100fa;">增1/减1运算（影响除CF以外的标志，不区分无/带符号）</span> <ul><li><span style="color:#01460f;">INC：加，包括incb、incw、incl等</span></li> <li><span style="color:#01460f;">DEC：减，包括decb、decw、decl等</span></li></ul></li> <li><span style="color:#1100fa;">取负运算（影响标志、若对0取负，则结果为0且CF = 0，否则CF = 1）</span> <ul><li><span style="color:#01460f;">NEG：取负，包括negb、negw、negl等</span></li></ul></li> <li><span style="color:#1100fa;">比较运算（做减法得到标志、不区分无/带符号）</span> <ul><li><span style="color:#01460f;">CMP：比较，包括cpmb、cmpw、cmpl等</span></li></ul></li> <li><span style="color:#1100fa;">乘/除运算（区分无/带符号）</span> <ul><li><span style="color:#01460f;">MUL/IMUL：无符号乘/带符号乘（影响标志OF和CF）</span></li> <li><span style="color:#01460f;">DIV/IDIV：无符号除/带符号除</span></li></ul></li></ul></li></ul> <h3 id="ia-32常用指令类型-3"><a href="#ia-32常用指令类型-3" class="header-anchor">#</a> IA-32常用指令类型</h3> <ul><li>按位运算指令
<ul><li><span style="color:#1100fa;">逻辑运算（仅NOT不影响标志，其他指令OF = CF = 0，而ZF和SF根据结果设置：若全0，则ZF = 1；若最高位为1，则SF = 1）</span> <ul><li><span style="color:#01460f;">NOT：非包括notb、notw、notl等</span></li> <li><span style="color:#01460f;">AND：与，包括andb、andw、andl等</span></li> <li><span style="color:#01460f;">OR：或，包括orb、orw、orl等</span></li> <li><span style="color:#01460f;">XOR：异或，包括xorb、xorw、xorl等</span></li> <li><span style="color:#01460f;">TEST：做“与”操作测试，仅影响标志</span></li></ul></li> <li><span style="color:#1100fa;">移位运算（左/右移时，最高/最低位送CF）</span> <ul><li><span style="color:#01460f;">SHL/SHR：逻辑左/右移，包括shlb、shrw、shrl等</span></li> <li><span style="color:#01460f;">SAL/SAR：算术左/右移，</span><span style="color:#ff0000;">左移判溢出，</span><span style="color:#01460f;">右移高位补符</span><span style="color:#ff0000;">（移位前、后符号位发生变化，则OF=1）</span></li> <li><span style="color:#01460f;">ROL/ROR：循环左/右移，包括rolb、rorw、roll等</span></li> <li><span style="color:#01460f;">RCL/RCR：带进位循环左/右移，将CF作为操作数一部分循环位移</span></li></ul></li></ul></li></ul> <h3 id="ia-32常用指令类型-4"><a href="#ia-32常用指令类型-4" class="header-anchor">#</a> IA-32常用指令类型</h3> <ul><li>控制转移指令
<ul><li>指令执行可<span style="color:#ff0000;">按顺序</span>或<span style="color:#ff0000;">跳转到目标指令处</span>执行</li> <li><span style="color:#1100fa;">无条件转移指令</span> <ul><li><span style="color:#01460f;">JMP DST：无条件转移到目标指令DST处执行</span></li></ul></li> <li><span style="color:#1100fa;">条件转移指令</span> <ul><li><span style="color:#01460f;">Jcc DST：cc为条件码，根据标志（条件码）判断是否满足条件，若满足，则转移到目标指令DST处执行，否则按顺序执行</span></li></ul></li> <li><span style="color:#1100fa;">条件设置</span> <ul><li><span style="color:#01460f;">SETcc DST：将条件码cc保存到DST（通常是一个8位寄存器）</span></li></ul></li> <li><span style="color:#1100fa;">调用和返回指令（用于过程调用）</span> <ul><li><span style="color:#01460f;">CALL DST：返回地址RA入栈，转DST处执行</span></li> <li><span style="color:#01460f;">RET：从栈中取出返回地址RA，转到RA处执行</span></li></ul></li> <li><span style="color:#1100fa;">中断指令</span></li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191430932.png" alt="image.png"></p> <h3 id="程序的机器级表示与执行"><a href="#程序的机器级表示与执行" class="header-anchor">#</a> 程序的机器级表示与执行</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191444455.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191446945.png" alt="image.png"></p> <h3 id="例子-c表达式类型转换顺序"><a href="#例子-c表达式类型转换顺序" class="header-anchor">#</a> 例子：C表达式类型转换顺序</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191449901.png" alt="image.png"></p> <h2 id="c语言程序的机器级表示"><a href="#c语言程序的机器级表示" class="header-anchor">#</a> C语言程序的机器级表示</h2> <h3 id="过程调用的机器级表示"><a href="#过程调用的机器级表示" class="header-anchor">#</a> 过程调用的机器级表示</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191506581.png" alt="image.png"></p> <h3 id="过程调用的机器级表示-2"><a href="#过程调用的机器级表示-2" class="header-anchor">#</a> 过程调用的机器级表示</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191509182.png" alt="image.png"></p> <h3 id="过程调用的机器级表示-3"><a href="#过程调用的机器级表示-3" class="header-anchor">#</a> 过程调用的机器级表示</h3> <ul><li>IA-32的寄存器使用约定
<ul><li><span style="color:#1100fa;">调用者P保存寄存器：EAX、EDX、ECX</span> <ul><li><span style="color:#ff0000;">Q可直接使用这三个寄存器</span></li> <li><span style="color:#ff0000;">若P在从Q返回后还要用的话，P应在转到Q前先保存，并在从Q返回后先恢复它们的值再使用</span></li></ul></li> <li><span style="color:#1100fa;">被调用者Q保存寄存器：EBX、ESI、EDI</span> <ul><li><span style="color:#ff0000;">Q必须先将它们的值保存到栈中再使用它们，并在返回P之前恢复它们的值</span></li></ul></li> <li><span style="color:#1100fa;">EBP和ESP分别是</span><span style="color:#ff0000;">帧指针寄存器</span><span style="color:#1100fa;">和</span><span style="color:#ff0000;">栈指针寄存器</span>，<span style="color:#1100fa;">分别用来指向</span><span style="color:#ff0000;">当前栈帧</span><span style="color:#1100fa;">的底部和顶部</span> <span style="color:#ff0000;">问题：为减少准备和结束阶段的开销，每个过程应先使用哪些寄存器？</span> <span style="color:#1100fa;">EAX、ECX、EDX！
</span></li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191530358.png" alt="image.png"></p> <h3 id="一个简单的过程调用例子"><a href="#一个简单的过程调用例子" class="header-anchor">#</a> 一个简单的过程调用例子</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191541583.png" alt="image.png"></p> <h3 id="过程-函数-的结构"><a href="#过程-函数-的结构" class="header-anchor">#</a> 过程（函数）的结构</h3> <ul><li>一个C过程的大致结构如下：
<ul><li><span style="color:#1100fa;">准备阶段</span> <ul><li><span style="color:#01460f;">形成帧底：push指令和mov指令</span></li> <li><span style="color:#01460f;">生成栈帧（如果有需要的话）：sub指令或and指令</span></li> <li><span style="color:#01460f;">保存现场（如果有被调用者保存寄存器）：mov指令</span></li></ul></li> <li><span style="color:#1100fa;">过程（函数）体</span> <ul><li><span style="color:#01460f;">分配局部变量空间，并赋值</span></li> <li><span style="color:#01460f;">具体处理逻辑，如果遇到函数调用时</span> <ul><li><span style="color:#ff0000;">准备参数：将实参送栈帧入口参数处</span></li> <li><span style="color:#ff0000;">CALL指令：保存返回地址并转被调用函数</span></li></ul></li> <li><span style="color:#01460f;">在EAX中准备返回参数</span></li></ul></li> <li><span style="color:#1100fa;">结束阶段</span> <ul><li><span style="color:#01460f;">退栈：leave指令或pop指令</span></li> <li><span style="color:#01460f;">取返回地址返回：ret指令</span></li></ul></li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191608819.png" alt="image.png"></p> <h3 id="过程调用参数传递举例"><a href="#过程调用参数传递举例" class="header-anchor">#</a> 过程调用参数传递举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191617180.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191618088.png" alt="image.png"></p> <h3 id="过程调用举例"><a href="#过程调用举例" class="header-anchor">#</a> 过程调用举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191627615.png" alt="image.png"></p> <h3 id="递归调用举例"><a href="#递归调用举例" class="header-anchor">#</a> 递归调用举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191634562.png" alt="image.png"></p> <h3 id="过程调用的机器级表示-4"><a href="#过程调用的机器级表示-4" class="header-anchor">#</a> 过程调用的机器级表示</h3> <ul><li>递归函数nn_sum的执行流程
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191635522.png" alt="image.png"> <span style="color:#1100fa;">为支持过程调用，每个过程包含准备阶段和结束阶段。因而</span><span style="color:#ff0000;">每增加一次过程调用，就要增加许多条包含在准备阶段的额外指令，</span><span style="color:#1100fa;">它们对程序的性能影响很大，应尽量避免不必要的过程调用，特别是递归调用</span></li></ul> <h3 id="过程调用举例-2"><a href="#过程调用举例-2" class="header-anchor">#</a> 过程调用举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191651885.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191651906.png" alt="image.png"></p> <h3 id="有关-过程调用-的练习"><a href="#有关-过程调用-的练习" class="header-anchor">#</a> 有关“过程调用”的练习</h3> <blockquote><p>假设P为调用过程，Q为被调用过程，程序在IA-32处理器上执行，以下有关过程调用的叙述，错误的是（<span style="color:#ff0000;">B</span>）。</p></blockquote> <div class="language- extra-class"><pre><code>A. C语言程序中的函数调用就是过程调用
B. 从P传到Q的实参无需重新分配空间存放
C. 从P跳转到Q执行应使用CALL指令
D. 从Q跳回到P执行应使用RET指令
</code></pre></div><blockquote><p>假设P为调用过程，Q为被调用过程，程序在IA-32处理器上执行，以下是C语言程序中过程调用所涉及的操作：
①过程Q保存P的现场，并为非静态局部变量分配空间
②过程P将实参存放到Q能访问到的地方
③过程P将返回地址存放到特定处，并跳转到Q执行
④过程Q取出返回地址，并跳转会过程P执行
⑤过程Q恢复P的现场，并释放局部变量所占空间
⑥执行过程Q的函数体
过程调用的正确执行步骤是（<span style="color:#ff0000;">C</span>）。
A. ②→③→④→①→⑤→⑥					
B. ②→③→①→④→⑥→⑤
C. ②→③→①→⑥→⑤→④					
D. ②→③→①→⑤→⑥→④</p></blockquote> <blockquote><p>以下是有关IA-32/Linux（GCC）的过程调用的叙述，错误的是（<span style="color:#ff0000;">A</span>）
A. 在过程中通常先使用被调用者保存寄存器
B. 每个非叶子过程都有一个栈帧，其大小为16B的倍数
C. EBP寄存器中的内容指向对应栈帧（stack frame）的底部
D. 每个栈帧底部单元中存放其调用过程的EBP内容</p></blockquote> <blockquote><p>以下是有关IA-32/Linux的过程调用的叙述，错误的是（<span style="color:#ff0000;">C</span>）。
A. 每进行一次过程调用，用户栈从高地址向低地址增长出一个栈帧
B. 从被调用过程返回调用过程之前，被调用过程会释放自己的栈帧
C. 只能通过将栈指针ESP作为基址寄存器来访问用户栈中的数据（<span style="color:#ff0000;">也可以使用EBP寄存器</span>）
D. 过程嵌套调用深度越深，栈中栈帧个数越多，严重时会发生栈溢出</p></blockquote> <blockquote><p>以下是有关C程序的变量作用域和生存期的叙述，错误的是（<span style="color:#ff0000;">A</span>）。
A. 静态（static型）变量和非静态局部变量都分配在对应栈帧中（<span style="color:#ff0000;">全局变量和静态变量连续存放在可读写数据区，非静态局部变量分配在栈中</span>）
B. 因为非静态局部变量被分配在栈中，所以其作用域仅在过程体内
C. 非静态局部变量可以与全局变量同名，因为它们被分配在不同存储区
D. 不同函数中非静态局部变量可以同名，因为它们被分配在不同栈帧中</p></blockquote> <blockquote><p>以下有关递归过程调用的叙述中，错误的是（<span style="color:#ff0000;">C</span>）。
A. 每次递归调用都会额外执行多条指令，因而时间开销大
B. 每次递归调用都会生成一个新的栈帧，因而空间开销大
C. 每次递归调用在栈帧中保存的返回地址都不相同
D. 递归过程第一个参数的有效地址为R[ebp]+8</p></blockquote> <blockquote><p>以下是一个C语言程序代码：</p></blockquote> <div class="language-C extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
     <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">caller</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
     <span class="token keyword">int</span> t1<span class="token operator">=</span><span class="token number">100</span> <span class="token punctuation">;</span>
     <span class="token keyword">int</span> t2<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token function">add</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>以下关于上述程序代码在 IA-32上执行情况的叙述中，错误的是（<span style="color:#ff0000;">C</span>）。
A. 变量t1、t2和sum被分配在寄存器或caller函数的栈帧中
B. 传递参数时t2和t1的值从高地址到低地址依次存入栈中
C. 入口参数t1和t2的值被分配在add函数的栈帧中
D. add函数返回时返回值存放在EAX寄存器中</p></blockquote> <blockquote><p>以下是一个C语言程序代码：</p></blockquote> <div class="language-C extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>xp<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>yp<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">*</span>xp<span class="token operator">+</span><span class="token operator">*</span>yp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">caller</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
     <span class="token keyword">static</span> <span class="token keyword">int</span> t1<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
     <span class="token keyword">static</span> <span class="token keyword">int</span> t2<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> diff<span class="token operator">=</span><span class="token function">sub</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span>“sum<span class="token operator">=</span><span class="token operator">%</span>d<span class="token punctuation">,</span> diff<span class="token operator">=</span><span class="token operator">%</span>d&quot;<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>以下关于上述代码在 IA-32/Linux上执行情况的叙述中，错误的是（<span style="color:#ff0000;">B</span>）。
A. 变量t1、t2被分配在可读可写的全局静态数据区中
B. 存入栈中的入口参数可能是0xbfff0004、0xbfff0000（<span style="color:#ff0000;">存入栈中的入口参数地址应该是相对于当前栈帧指针的偏移量，而不是硬编码的地址值。因此无法确定参数地址具体是什么</span>）
C. 在caller中执行leave指令后，入口参数的值还在存储器中
D. add函数和sub函数的栈帧底部在完全相同的位置处</p></blockquote> <h3 id="逆向工程举例"><a href="#逆向工程举例" class="header-anchor">#</a> 逆向工程举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306191752549.png" alt="image.png"></p> <h3 id="数组的分配和访问"><a href="#数组的分配和访问" class="header-anchor">#</a> 数组的分配和访问</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192018970.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192019749.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192101843.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192111650.png" alt="image.png"> <span style="color:#ff0000;">对buf进行初始化的指令是什么？</span> <span style="color:#1100fa;">movl $10, -8(%ebp)    //buf[0]的地址R[ebp]-8，将10赋给buf[0]</span> <span style="color:#1100fa;">movl $20, -4(%ebp)  //buf[1]的地址为R[ebp]-4，将20赋buf[1]</span> <span style="color:#ff0000;">若buf首地址在EDX中，则获得buf首址的对应指令是什么？</span> <span style="color:#1100fa;">leal -8(%ebp), %edx  //buf[0]的地址为R[ebp]-8，将buf首址送EDX</span></p> <h3 id="数组元素在内存的存放和访问"><a href="#数组元素在内存的存放和访问" class="header-anchor">#</a> 数组元素在内存的存放和访问</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192133560.png" alt="image.png"></p> <ul><li>数值与指针</li> <li><span style="color:#ff0000;">在指针的目标数据类型与数组类型相同的前提下</span>，<span style="color:#1100fa;">指针变量可以指向数组或数组中任意元素</span></li> <li><span style="color:#1100fa;">以下两个程序段功能完全相同，都是使ptr指向数组a的第0个元素a[0]。a的值就是其首地址，即</span><span style="color:#ff0000;">a = &amp;a[0]</span><span style="color:#1100fa;">，因而a = ptr，从而有</span><span style="color:#ff0000;">&amp;a[i] = ptr + i = a + i</span><span style="color:#1100fa;">以及</span><span style="color:#ff0000;">a[i] = ptr[i] = *(ptr + i) = *(a + i)</span></li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>小端方式下a[0] = ?，a[1] = ?
<span style="color:#01460f;">a[0] = 0x67452301, a[1] = 0x0efcdab</span> <span style="color:#ff0000;">数组首地址0x8048A00在ptr中，ptr + i并不是用0x8048A00加i得到，而是等于</span><span style="color:#1100fa;">0x8048A00 +4*i</span></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192201729.png" alt="image.png"></p> <h3 id="数组元素在内存的存放和访问-2"><a href="#数组元素在内存的存放和访问-2" class="header-anchor">#</a> 数组元素在内存的存放和访问</h3> <ul><li>指针数组和多维数组
<ul><li><span style="color:#1100fa;">由若干指向同类目标的指针变量组成的数组称为指针数值</span></li> <li><span style="color:#1100fa;">其定义的一般形式如下</span> <ul><li><span style="color:#fa7900;">存储类型 数据类型 *指针数组名[元素个数];</span></li></ul></li> <li><span style="color:#1100fa;">例如：“int* a[10];”定义了一个指针数组a，它有10个元素，每个元素都是一个指向int型数据的指针</span></li></ul></li> <li><span style="color:#01460f;">一个指针数组可以实现一个二维数组</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192209867.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192220596.png" alt="image.png"></li></ul> <h3 id="结构体数据的分配和访问"><a href="#结构体数据的分配和访问" class="header-anchor">#</a> 结构体数据的分配和访问</h3> <ul><li>结构体成员在内存的存放和访问
<ul><li><span style="color:#1100fa;">分配在栈中的auto结构型变量的首地址由EBP或ESP来定位</span></li> <li><span style="color:#1100fa;">分配在静态区的结构型变量首地址是一个确定的静态区地址</span></li> <li><span style="color:#1100fa;">结构型变量x各成员首址可用“基址加偏移量”的寻址方式</span> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs_2/202306192229610.png" alt="image.png"></li></ul></li></ul> <h3 id="越界访问和缓冲区溢出"><a href="#越界访问和缓冲区溢出" class="header-anchor">#</a> 越界访问和缓冲区溢出</h3> <ul><li>造成缓冲区溢出的原因是没有对栈中作为缓冲区的数组的访问进行越界检查。
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620000827.png" alt="image.png"></li></ul> <h1 id="第四章-程序的链接"><a href="#第四章-程序的链接" class="header-anchor">#</a> 第四章 程序的链接</h1> <h2 id="目标文件格式"><a href="#目标文件格式" class="header-anchor">#</a> 目标文件格式</h2> <h3 id="链接器的由来"><a href="#链接器的由来" class="header-anchor">#</a> 链接器的由来</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620071649.png" alt="image.png"></p> <h3 id="链接操作的步骤"><a href="#链接操作的步骤" class="header-anchor">#</a> 链接操作的步骤</h3> <ul><li>符号解析
<ul><li>程序中有定义和引用的符号（包括变量和函数等）
<ul><li><code>void swap() {...} /*定义符号swap*/</code></li> <li><code>swap(); /*引用符号swap*/</code></li> <li><code>int *xp = &amp;x; /*定义符号xp，引用符号x*/</code></li></ul></li> <li>编译器将定义的符号存放在一个符号表中
<ul><li>符号表是一个结构数组</li> <li>每个表项包含符号名、长度和位置等信息</li></ul></li> <li>链接器将每个符号的引用都与一个确定的符号定义建立关联</li></ul></li> <li>重定位
<ul><li>将多个代码段与数据段分别合并为一个单独的代码段和数据段</li> <li>计算每个定义的符号在虚拟地址空间中的绝对地址</li> <li>将可执行文件中符号引用处的地址修改为重定位后的地址信息</li></ul></li></ul> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620072315.png" alt="image.png"></p> <h3 id="使用链接的好处"><a href="#使用链接的好处" class="header-anchor">#</a> 使用链接的好处</h3> <p>链接带来的好处1：模块化</p> <ul><li>一个程序可分成很多源程序文件</li> <li>可构建公共函数库，如数学库，标准I/O库等</li> <li>多人开发、代码重用、开发效率高
链接带来的好处2：效率高</li> <li>时间上，可分开编译
<ul><li>只需重新编译被修改的源程序文件，然后重新链接</li></ul></li> <li>空间上，无需包含共享库所有代码
<ul><li>源程序中无需包含共享库函数的源码，只要直接调用即可，可执行文件和运行时的内存中只需要包含所调用函数的代码而不需要包含整个共享库</li></ul></li></ul> <h3 id="一个c语言程序举例"><a href="#一个c语言程序举例" class="header-anchor">#</a> 一个C语言程序举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620074709.png" alt="image.png">
局部变量（temp）分配在栈中，不会在过程（函数）外被引用，因此不是符号定义</p> <h3 id="链接过程的本质"><a href="#链接过程的本质" class="header-anchor">#</a> 链接过程的本质</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620075734.png" alt="image.png"></p> <h3 id="可执行文件的存储器映射"><a href="#可执行文件的存储器映射" class="header-anchor">#</a> 可执行文件的存储器映射</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620075958.png" alt="image.png"></p> <h3 id="三类目标文件"><a href="#三类目标文件" class="header-anchor">#</a> 三类目标文件</h3> <ul><li>可重定位目标文件（.o）
<ul><li>其代码和数据可和其他可重定位文件合并为可执行文件
<ul><li>每个.o文件由对应的.c文件生成</li> <li>每个.o文件代码和数据地址都从0开始</li></ul></li></ul></li> <li>可执行目标文件（默认为a.out）
<ul><li>包含的代码和数据可直接被复制到内存并执行</li> <li>代码和数据的地址为虚拟地址空间中的地址</li></ul></li> <li>共享的目标文件（.so）
<ul><li>特殊的可重定位目标文件，能在装入或运行时被装入到内存并自动被链接，称为共享库文件</li></ul></li></ul> <h3 id="链接视图-可重定位目标文件"><a href="#链接视图-可重定位目标文件" class="header-anchor">#</a> 链接视图——可重定位目标文件</h3> <ul><li>可被链接（合并）生成可执行文件或共享目标文件</li> <li>静态链接库文件由若干个可重定向目标文件组成</li> <li>包含代码、数据（已初始化的全局变量和局部静态变量.data和未初始化的全局变量和局部静态变量.bss）</li> <li>包含重定位信息（指出哪些符号引用处需要重定位）</li> <li>文件扩展名为.o（相当于Windows中的.obj文件）
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620081331.png" alt="image.png"></li></ul> <h3 id="executable-and-linkable-format-elf"><a href="#executable-and-linkable-format-elf" class="header-anchor">#</a> Executable and Linkable Format (ELF)</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620082300.png" alt="image.png"></p> <h3 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="header-anchor">#</a> 可重定位目标文件格式</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620082507.png" alt="image.png"></p> <h3 id="bss节"><a href="#bss节" class="header-anchor">#</a> .bss节</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620082822.png" alt="image.png"></p> <h3 id="可执行目标文件格式"><a href="#可执行目标文件格式" class="header-anchor">#</a> 可执行目标文件格式</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620083608.png" alt="image.png"></p> <h3 id="链接符号的类型"><a href="#链接符号的类型" class="header-anchor">#</a> 链接符号的类型</h3> <ul><li>每个可重定位目标模块m都有一个符号表，它包含了在m中定义的符号。分三种（链接器符号）：
<ul><li>Global symbols（模块内部定义的，全局符号）
<ul><li>由模块m定义并能被其他模块引用的符号。例如，非static C函数和非static的C全局变量（指不带static的全局变量）</li> <li>如，main.c中的全局变量名buf</li></ul></li> <li>External symbols（外部定义的，外部符号）
<ul><li>由其他模块定义并被模块m引用的全局符号</li> <li>如main.c中的函数名swap，swap.c中的变量名buf</li></ul></li> <li>Local symbols（本模块定义并引用的，局部符号）
<ul><li>仅由模块m定义和引用的本地符号。</li> <li>例如，在模块m中定义的带static的C函数和变量</li> <li>如，swap.c中的static变量名bufp1
链接器局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量</li></ul></li></ul></li></ul> <h3 id="符号和符号解析"><a href="#符号和符号解析" class="header-anchor">#</a> 符号和符号解析</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620093346.png" alt="image.png"></p> <h3 id="全局符号的强、弱"><a href="#全局符号的强、弱" class="header-anchor">#</a> 全局符号的强、弱</h3> <ul><li>全局符号的强/弱特性
<ul><li>函数名和已初始化的全局变量名是强符号</li> <li>未初始化的全局变量名是弱符号
<img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620094429.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620094443.png" alt="image.png"></li></ul></li></ul> <h3 id="链接器对符号的解析规则"><a href="#链接器对符号的解析规则" class="header-anchor">#</a> 链接器对符号的解析规则</h3> <p>符号解析时：只认定一个定义，即每个符号仅占一处存储空间</p> <ul><li>多重定义符号的处理规则
<ul><li>Rule1：一个符号不允许被多次定义为强符号
<ul><li>强符号只能被定义一次，否则链接错误</li></ul></li> <li>Rule2：若一个符号被定义为一次强符号、多次弱符号，只认定强定义
<ul><li>弱符号的引用将被解析为其强定义符号</li></ul></li> <li>Rule3：若有多个弱符号定义，则任选其中一个
<ul><li>-gcc -fno -common：链接时，若遇到有多个若定义的全局符号，则输出一条警告</li></ul></li></ul></li></ul> <h3 id="多重定义符号的解析举例"><a href="#多重定义符号的解析举例" class="header-anchor">#</a> 多重定义符号的解析举例</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620095826.png" alt="image.png"></p> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620100439.png" alt="image.png"> <img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620100507.png" alt="image.png"></p> <h3 id="多重定义全局符号的问题"><a href="#多重定义全局符号的问题" class="header-anchor">#</a> 多重定义全局符号的问题</h3> <ul><li>模块间相互引用容易出错，故应尽量避免使用全局变量</li> <li>一定需要用的话，就按如下规则使用
<ul><li>尽量使用本地变量（static），模块内引用不太会出错</li> <li>全局变量要赋初值，使成为强符号，易查出链接错误</li> <li>外部全局变量使用extern，以示其引用的定义在其他模块
多重定义全局变量会造成一些意想不到的错误，而且是默默发生的，编译系统不会警告，并会在程序执行很久后才能表现出来，且远离错误引发处。特别是在一个具有几百个模块的大型软件中，这类错误很难修正。</li></ul></li></ul> <h3 id="使用静态库"><a href="#使用静态库" class="header-anchor">#</a> 使用静态库</h3> <ul><li>链接器对外部引用的解析算法要点如下：
<ul><li>按照命令行给出的顺序扫描.o和.a文件</li> <li>扫描期间将当前未解析的引用记录到一个列表U中</li> <li>每遇到一个新的.o或.a中的模块，都试图用其来解析U中的符号</li> <li>如果扫描到最后，U中还有未被解析的符号，则发生错误</li></ul></li> <li>问题和对策
<ul><li>能否正确解析与命令行给出的顺序有关</li> <li>好的做法 ：将静态库放在命令行的最后</li></ul></li></ul> <h3 id="链接顺序问题"><a href="#链接顺序问题" class="header-anchor">#</a> 链接顺序问题</h3> <p><img src="https://gitee.com/yelishu/note/raw/master/noteImgs/20230620102025.png" alt="image.png"></p> <h1 id="测试题"><a href="#测试题" class="header-anchor">#</a> 测试题</h1> <blockquote><p>以下有关冯·诺依曼结构思想的叙述中，错误的是（<span style="color:#ff0000;">B</span>）
A.程序由指令构成,计算机能自动执行程序中一条一条指令
B.指令和数据都放在存储器中,两者在形式上有差别（<span style="color:#ff0000;">指令和数据在存储器中的位置形式上没有差别，在计算机内部，指令和数据都是以二进制形式存储和表示的</span>）
C.计算机内部以二进制形式表示指令和数据
D.计算机由运算器、存储器、控制器和 I/O 设备组成</p></blockquote> <blockquote><p>以下有关冯.诺依曼计算机结构中指令和数据表示形式的叙述中,正确的是（<span style="color:#ff0000;">C</span>）
A.
指令和数据可以从形式上加以区分
B.
指令以二进制形式存放,数据以十进制形式存放
C.
指令和数据都以二进制形式存放
D.
指令和数据都以十进制形式存放</p></blockquote> <blockquote><p>以下有关指令以及指令执行过程的叙述中,错误的是（<span style="color:#ff0000;">A</span>）
A.（<span style="color:#ff0000;">指令中指定的操作数可以来自寄存器或存储器。</span>）
指令中指定的操作数只能是存放在存储器中的数据
B.
将要执行的下条指令的地址总是在程序计数器 PC 中
C.
CPU 中的控制器对指令操作码进行译码
D.
指令由操作码和操作数或操作数的地址码构成</p></blockquote> <blockquote><p>假设你是个卡车司机,要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis,全程 2500 公里。在限速范围内,你估计平均速度为 100 公里/小时,整个行程需要 25 小时。在这段行程中,蒙大拿州境内有 1500 公里,同时蒙大拿州取消了限速要求。那么,如果你希望加速比达到 1.67 倍,在蒙大拿州的速度是多少?（<span style="color:#ff0000;">D</span>）
A.
150 公里/小时
B.
200 公里/小时
C.
250 公里/小时
D.
300 公里/小时</p></blockquote> <p>$$
加速比 = \frac{加速前时间}{加速后时间}
$$
$$
加速比 = \frac{25}{\frac{1500}{x} +\frac1000{100}} = 1.67，解x =300
$$</p> <blockquote><p>若某典型基准测试程序在机器 A 上运行需要 20s,而在机器 B 上的运行时间是 16s,则相对来说,下面说法正确的是:（<span style="color:#ff0000;">B</span>）
A.
机器 B 的速度是机器 A 的 0.8 倍
B.
机器 B 的速度是机器 A 的 1.25 倍
C.
机器 A 的速度是机器 B 的 1.25 倍
D.
以上都不对</p></blockquote> <blockquote><p>某程序 P 在 A 计算机上运行完毕需 10 秒,A 计算机时钟频率为2GHz。设计一台 B 计算机,该程序 P 在 B 计算机上运行完毕只需6 秒,由于设计原因 P 在 B 计算机运行的时钟周期数是在 A 计算机运行的 1.2 倍,B 计算机的时钟频率是多少?（<span style="color:#ff0000;">D</span>）
A.
1.2GHz
B.
1GHz
C.
8GHz
D.
4GHz</p></blockquote> <p>$$
CPU时间A = \frac{时钟周期数A}{时钟频率A}
$$
$$
CPU时间B = \frac{时钟周期数B}{时钟频率B}
$$</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#现代计算机的原型" class="sidebar-link reco-side-现代计算机的原型" data-v-b57cc07c>现代计算机的原型</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#数值数据的表示" class="sidebar-link reco-side-数值数据的表示" data-v-b57cc07c>数值数据的表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#信息的二进制编码" class="sidebar-link reco-side-信息的二进制编码" data-v-b57cc07c>信息的二进制编码</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数值数据的表示-2" class="sidebar-link reco-side-数值数据的表示-2" data-v-b57cc07c>数值数据的表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#十进制数与r进制数之间的转换" class="sidebar-link reco-side-十进制数与r进制数之间的转换" data-v-b57cc07c>十进制数与R进制数之间的转换</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#定点数和浮点数" class="sidebar-link reco-side-定点数和浮点数" data-v-b57cc07c>定点数和浮点数</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#原码表示" class="sidebar-link reco-side-原码表示" data-v-b57cc07c>原码表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#移码" class="sidebar-link reco-side-移码" data-v-b57cc07c>移码</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#补码" class="sidebar-link reco-side-补码" data-v-b57cc07c>补码</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#无符号整数和带符号整数" class="sidebar-link reco-side-无符号整数和带符号整数" data-v-b57cc07c>无符号整数和带符号整数</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#浮点数" class="sidebar-link reco-side-浮点数" data-v-b57cc07c>浮点数</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#第一讲小节" class="sidebar-link reco-side-第一讲小节" data-v-b57cc07c>第一讲小节</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#非数值数据的表示、数据的存储" class="sidebar-link reco-side-非数值数据的表示、数据的存储" data-v-b57cc07c>非数值数据的表示、数据的存储</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数据的基本宽度" class="sidebar-link reco-side-数据的基本宽度" data-v-b57cc07c>数据的基本宽度</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数据量的度量单位" class="sidebar-link reco-side-数据量的度量单位" data-v-b57cc07c>数据量的度量单位</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#程序中数据类型的宽度" class="sidebar-link reco-side-程序中数据类型的宽度" data-v-b57cc07c>程序中数据类型的宽度</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数据的存储和排列顺序" class="sidebar-link reco-side-数据的存储和排列顺序" data-v-b57cc07c>数据的存储和排列顺序</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#大端-小端方式举例" class="sidebar-link reco-side-大端-小端方式举例" data-v-b57cc07c>大端/小端方式举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#字节交换问题" class="sidebar-link reco-side-字节交换问题" data-v-b57cc07c>字节交换问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#c表达式类型转换顺序" class="sidebar-link reco-side-c表达式类型转换顺序" data-v-b57cc07c>C表达式类型转换顺序</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#第二讲小结" class="sidebar-link reco-side-第二讲小结" data-v-b57cc07c>第二讲小结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#数据的运算" class="sidebar-link reco-side-数据的运算" data-v-b57cc07c>数据的运算</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#c语言程序中涉及的运算" class="sidebar-link reco-side-c语言程序中涉及的运算" data-v-b57cc07c>C语言程序中涉及的运算</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#n位整数加-减运算器" class="sidebar-link reco-side-n位整数加-减运算器" data-v-b57cc07c>n位整数加/减运算器</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#算术逻辑部件alu" class="sidebar-link reco-side-算术逻辑部件alu" data-v-b57cc07c>算术逻辑部件ALU</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#所有运算电路的核心" class="sidebar-link reco-side-所有运算电路的核心" data-v-b57cc07c>所有运算电路的核心</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#条件标志位-条件码cc" class="sidebar-link reco-side-条件标志位-条件码cc" data-v-b57cc07c>条件标志位（条件码CC）</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#n位带标志加法器" class="sidebar-link reco-side-n位带标志加法器" data-v-b57cc07c>n位带标志加法器</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#整数加法举例-判溢出" class="sidebar-link reco-side-整数加法举例-判溢出" data-v-b57cc07c>整数加法举例：判溢出</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#整数减法举例-判大小" class="sidebar-link reco-side-整数减法举例-判大小" data-v-b57cc07c>整数减法举例：判大小</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#整数减法举例" class="sidebar-link reco-side-整数减法举例" data-v-b57cc07c>整数减法举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#整数加法举例" class="sidebar-link reco-side-整数加法举例" data-v-b57cc07c>整数加法举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ieee-754-标准规定的五种异常情况" class="sidebar-link reco-side-ieee-754-标准规定的五种异常情况" data-v-b57cc07c>IEEE 754 标准规定的五种异常情况</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#浮点数加-减运算" class="sidebar-link reco-side-浮点数加-减运算" data-v-b57cc07c>浮点数加/减运算</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#浮点数加减法基本要点" class="sidebar-link reco-side-浮点数加减法基本要点" data-v-b57cc07c>浮点数加减法基本要点</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#浮点数加法运算举例" class="sidebar-link reco-side-浮点数加法运算举例" data-v-b57cc07c>浮点数加法运算举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#附加位" class="sidebar-link reco-side-附加位" data-v-b57cc07c>附加位</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ieee-754的舍入方式的说明" class="sidebar-link reco-side-ieee-754的舍入方式的说明" data-v-b57cc07c>IEEE 754的舍入方式的说明</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#c语言中的浮点数类型" class="sidebar-link reco-side-c语言中的浮点数类型" data-v-b57cc07c>C语言中的浮点数类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#浮点数比较运算举例" class="sidebar-link reco-side-浮点数比较运算举例" data-v-b57cc07c>浮点数比较运算举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ieee-754的范围和精度" class="sidebar-link reco-side-ieee-754的范围和精度" data-v-b57cc07c>IEEE 754的范围和精度</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#程序转换概述" class="sidebar-link reco-side-程序转换概述" data-v-b57cc07c>程序转换概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#机器级指令" class="sidebar-link reco-side-机器级指令" data-v-b57cc07c>机器级指令</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32支持的数据类型及格式" class="sidebar-link reco-side-ia-32支持的数据类型及格式" data-v-b57cc07c>IA-32支持的数据类型及格式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#高级语言转换为机器代码的过程" class="sidebar-link reco-side-高级语言转换为机器代码的过程" data-v-b57cc07c>高级语言转换为机器代码的过程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32的定点寄存器组织" class="sidebar-link reco-side-ia-32的定点寄存器组织" data-v-b57cc07c>IA-32的定点寄存器组织</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32的寻址方式" class="sidebar-link reco-side-ia-32的寻址方式" data-v-b57cc07c>IA-32的寻址方式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#保护模式下的寻址方式" class="sidebar-link reco-side-保护模式下的寻址方式" data-v-b57cc07c>保护模式下的寻址方式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#存储器操作数的寻址方式" class="sidebar-link reco-side-存储器操作数的寻址方式" data-v-b57cc07c>存储器操作数的寻址方式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32指令系统" class="sidebar-link reco-side-ia-32指令系统" data-v-b57cc07c>IA-32指令系统</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32常用指令类型" class="sidebar-link reco-side-ia-32常用指令类型" data-v-b57cc07c>IA-32常用指令类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#入栈-pushw-ax" class="sidebar-link reco-side-入栈-pushw-ax" data-v-b57cc07c>“入栈”（pushw %ax）</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#出栈-popw-ax" class="sidebar-link reco-side-出栈-popw-ax" data-v-b57cc07c>“出栈”（popw %ax）</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32常用指令类型-2" class="sidebar-link reco-side-ia-32常用指令类型-2" data-v-b57cc07c>IA-32常用指令类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32常用指令类型-3" class="sidebar-link reco-side-ia-32常用指令类型-3" data-v-b57cc07c>IA-32常用指令类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#ia-32常用指令类型-4" class="sidebar-link reco-side-ia-32常用指令类型-4" data-v-b57cc07c>IA-32常用指令类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#程序的机器级表示与执行" class="sidebar-link reco-side-程序的机器级表示与执行" data-v-b57cc07c>程序的机器级表示与执行</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#例子-c表达式类型转换顺序" class="sidebar-link reco-side-例子-c表达式类型转换顺序" data-v-b57cc07c>例子：C表达式类型转换顺序</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#c语言程序的机器级表示" class="sidebar-link reco-side-c语言程序的机器级表示" data-v-b57cc07c>C语言程序的机器级表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用的机器级表示" class="sidebar-link reco-side-过程调用的机器级表示" data-v-b57cc07c>过程调用的机器级表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用的机器级表示-2" class="sidebar-link reco-side-过程调用的机器级表示-2" data-v-b57cc07c>过程调用的机器级表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用的机器级表示-3" class="sidebar-link reco-side-过程调用的机器级表示-3" data-v-b57cc07c>过程调用的机器级表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#一个简单的过程调用例子" class="sidebar-link reco-side-一个简单的过程调用例子" data-v-b57cc07c>一个简单的过程调用例子</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程-函数-的结构" class="sidebar-link reco-side-过程-函数-的结构" data-v-b57cc07c>过程（函数）的结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用参数传递举例" class="sidebar-link reco-side-过程调用参数传递举例" data-v-b57cc07c>过程调用参数传递举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用举例" class="sidebar-link reco-side-过程调用举例" data-v-b57cc07c>过程调用举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#递归调用举例" class="sidebar-link reco-side-递归调用举例" data-v-b57cc07c>递归调用举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用的机器级表示-4" class="sidebar-link reco-side-过程调用的机器级表示-4" data-v-b57cc07c>过程调用的机器级表示</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#过程调用举例-2" class="sidebar-link reco-side-过程调用举例-2" data-v-b57cc07c>过程调用举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#有关-过程调用-的练习" class="sidebar-link reco-side-有关-过程调用-的练习" data-v-b57cc07c>有关“过程调用”的练习</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#逆向工程举例" class="sidebar-link reco-side-逆向工程举例" data-v-b57cc07c>逆向工程举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数组的分配和访问" class="sidebar-link reco-side-数组的分配和访问" data-v-b57cc07c>数组的分配和访问</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数组元素在内存的存放和访问" class="sidebar-link reco-side-数组元素在内存的存放和访问" data-v-b57cc07c>数组元素在内存的存放和访问</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#数组元素在内存的存放和访问-2" class="sidebar-link reco-side-数组元素在内存的存放和访问-2" data-v-b57cc07c>数组元素在内存的存放和访问</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#结构体数据的分配和访问" class="sidebar-link reco-side-结构体数据的分配和访问" data-v-b57cc07c>结构体数据的分配和访问</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#越界访问和缓冲区溢出" class="sidebar-link reco-side-越界访问和缓冲区溢出" data-v-b57cc07c>越界访问和缓冲区溢出</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/blogs/16.html#目标文件格式" class="sidebar-link reco-side-目标文件格式" data-v-b57cc07c>目标文件格式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接器的由来" class="sidebar-link reco-side-链接器的由来" data-v-b57cc07c>链接器的由来</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接操作的步骤" class="sidebar-link reco-side-链接操作的步骤" data-v-b57cc07c>链接操作的步骤</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#使用链接的好处" class="sidebar-link reco-side-使用链接的好处" data-v-b57cc07c>使用链接的好处</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#一个c语言程序举例" class="sidebar-link reco-side-一个c语言程序举例" data-v-b57cc07c>一个C语言程序举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接过程的本质" class="sidebar-link reco-side-链接过程的本质" data-v-b57cc07c>链接过程的本质</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#可执行文件的存储器映射" class="sidebar-link reco-side-可执行文件的存储器映射" data-v-b57cc07c>可执行文件的存储器映射</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#三类目标文件" class="sidebar-link reco-side-三类目标文件" data-v-b57cc07c>三类目标文件</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接视图-可重定位目标文件" class="sidebar-link reco-side-链接视图-可重定位目标文件" data-v-b57cc07c>链接视图——可重定位目标文件</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#executable-and-linkable-format-elf" class="sidebar-link reco-side-executable-and-linkable-format-elf" data-v-b57cc07c>Executable and Linkable Format (ELF)</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#可重定位目标文件格式" class="sidebar-link reco-side-可重定位目标文件格式" data-v-b57cc07c>可重定位目标文件格式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#bss节" class="sidebar-link reco-side-bss节" data-v-b57cc07c>.bss节</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#可执行目标文件格式" class="sidebar-link reco-side-可执行目标文件格式" data-v-b57cc07c>可执行目标文件格式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接符号的类型" class="sidebar-link reco-side-链接符号的类型" data-v-b57cc07c>链接符号的类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#符号和符号解析" class="sidebar-link reco-side-符号和符号解析" data-v-b57cc07c>符号和符号解析</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#全局符号的强、弱" class="sidebar-link reco-side-全局符号的强、弱" data-v-b57cc07c>全局符号的强、弱</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接器对符号的解析规则" class="sidebar-link reco-side-链接器对符号的解析规则" data-v-b57cc07c>链接器对符号的解析规则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#多重定义符号的解析举例" class="sidebar-link reco-side-多重定义符号的解析举例" data-v-b57cc07c>多重定义符号的解析举例</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#多重定义全局符号的问题" class="sidebar-link reco-side-多重定义全局符号的问题" data-v-b57cc07c>多重定义全局符号的问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#使用静态库" class="sidebar-link reco-side-使用静态库" data-v-b57cc07c>使用静态库</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/blogs/16.html#链接顺序问题" class="sidebar-link reco-side-链接顺序问题" data-v-b57cc07c>链接顺序问题</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="https://yelishu.gitee.io/blogs/bg.mp3" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="https://p2.music.126.net/ZvYHj8W72RwrnOJiOGaL9g==/109951163074555333.jpg?param=130y130" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(https://p2.music.126.net/ZvYHj8W72RwrnOJiOGaL9g==/109951163074555333.jpg?param=130y130);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>❀</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>nevva</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/blogs/assets/js/app.b10d3b76.js" defer></script><script src="/blogs/assets/js/7.51cf2bb3.js" defer></script><script src="/blogs/assets/js/2.90913472.js" defer></script><script src="/blogs/assets/js/1.c35ebe2c.js" defer></script><script src="/blogs/assets/js/46.0eead14d.js" defer></script>
  </body>
</html>
