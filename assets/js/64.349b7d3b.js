(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{481:function(l,_,v){"use strict";v.r(_);var i=v(1),u=Object(i.a)({},(function(){var l=this,_=l._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("h3",{attrs:{id:"从输入url到看到页面发生的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到看到页面发生的过程"}},[l._v("#")]),l._v(" 从输入URL到看到页面发生的过程")]),l._v(" "),_("ul",[_("li",[_("p",[l._v("首先是输入url并回车")]),l._v(" "),_("ul",[_("li",[l._v("同源策略：在前端进行数据请求时，由于浏览器的同源策略，协议，域名，端口号有一个不同就会存在跨域请求，需要进行跨域处理\n"),_("ul",[_("li",[l._v("跨域处理的方法有很多，例如JSONP，CORS，代理服务器等")])])])])]),l._v(" "),_("li",[_("p",[l._v("浏览器查找当前url是否存在缓存，并比较缓存是否过期")]),l._v(" "),_("ul",[_("li",[l._v("没过期就读取缓存，过期了就访问服务器\n"),_("ul",[_("li",[l._v("浏览器缓存的机制是通过HTTP的Cache-Control，Expires，Last-Modified，ETag等响应头来控制的")])])])])]),l._v(" "),_("li",[_("p",[l._v("DNS解析url对应的ip")]),l._v(" "),_("ul",[_("li",[l._v("首先查看DNS缓存是否存在，没有则会先去hosts查找本地DNS解析器缓存，也没找到会查找路由器缓存，还没有的话按照运营商、根域名服务器、顶级域名服务器、主域名服务器的顺序逐步读取缓存直到拿到IP\n"),_("ul",[_("li",[l._v("DNS解析的过程是一个递归查询的过程，每一级的服务器都会返回下一级的地址，直到找到最终的IP地址")])])])])]),l._v(" "),_("li",[_("p",[l._v("根据ip建立TCP连接")]),l._v(" "),_("ul",[_("li",[l._v("通过三次握手建立TCP连接\n"),_("ul",[_("li",[l._v("客户端发送一个syn包：即带有SYN=1，Seq=x的数据包到服务器端口，并进入SYN_SENT状态，等待服务器确认（第一次握手，由浏览器发起，告诉服务器我要发送请求了）\n"),_("ul",[_("li",[l._v("SYN表示同步序列编号，Seq表示序列号，用来标识数据包的顺序")])])]),l._v(" "),_("li",[l._v("服务器收到syn包，必须确认客户的SYN，同时返回一个带SYN=1，ACK=x+1，Seq=y的响应包以传达确认信息，此时服务器进入SYN_RECV状态（第二次握手，由服务器发起，告诉浏览器我准备好了，你发送吧）\n"),_("ul",[_("li",[l._v("ACK表示确认号，用来确认收到的数据包")])])]),l._v(" "),_("li",[l._v("客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，即传回一个带ACK=y+1，Seq=z的数据包，代表握手结束（第三次握手，由浏览器告诉服务器，我马上发了，准备接收）\n"),_("ul",[_("li",[l._v("三次握手的目的是为了"),_("strong",[l._v("防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误")])])])])])])])]),l._v(" "),_("li",[_("p",[l._v("HTTP发起请求")]),l._v(" "),_("ul",[_("li",[l._v("服务器在收到浏览器发的HTTP请求后会将HTTP报文封装为HTTP的Request对象，并通过不同的web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包含状态码，响应头，响应报文三部分\n"),_("ul",[_("li",[l._v("HTTP请求报文的格式由请求行，请求头，空行，请求体四部分组成")]),l._v(" "),_("li",[l._v("HTTP响应报文的格式由状态行，响应头，空行，响应体四部分组成")]),l._v(" "),_("li",[l._v("HTTP的状态码分为五类，分别表示不同的响应状态，例如200表示成功，404表示未找到，500表示服务器错误等")])])])])]),l._v(" "),_("li",[_("p",[l._v("服务器处理请求，浏览器接收HTTP响应")]),l._v(" "),_("ul",[_("li",[l._v("服务器处理请求的过程可能涉及到路由，中间件，数据库，模板引擎等技术，具体取决于服务器的架构和业务逻辑")]),l._v(" "),_("li",[l._v("浏览器接收HTTP响应后，会根据响应头的内容进行相应的处理，例如设置缓存，重定向，跨域等")])])]),l._v(" "),_("li",[_("p",[l._v("浏览器解析渲染页面")]),l._v(" "),_("ul",[_("li",[l._v("浏览器拿到内容后，开始解析HTML，构建DOM树\n"),_("ul",[_("li",[l._v("DOM树是一种树形结构，表示文档的元素，属性，文本等节点之间的关系")])])]),l._v(" "),_("li",[l._v("解析CSS，构建CSS规则树\n"),_("ul",[_("li",[l._v("CSS规则树是一种树形结构，表示文档的样式规则，选择器，属性，值等节点之间的关系")])])]),l._v(" "),_("li",[l._v("结合CSS规则树和DOM数生成渲染树\n"),_("ul",[_("li",[l._v("渲染树是一种树形结构，表示文档的可见元素，样式，位置，大小等节点之间的关系")])])]),l._v(" "),_("li",[l._v("根据渲染树计算布局，然后绘制页面\n"),_("ul",[_("li",[l._v("重绘：不影响元素周围或内部布局的属性，只是改变文字颜色，背景颜色等\n"),_("ul",[_("li",[l._v("重绘是指当元素的外观发生变化，但不影响布局时，浏览器重新绘制元素的过程")])])]),l._v(" "),_("li",[l._v("回流：元素尺寸，位置发生变化，需要重新计算渲染树，重新渲染\n"),_("ul",[_("li",[l._v("回流是指当元素的布局发生变化，浏览器重新计算渲染树，并重新布局和绘制元素的过程")])])])])])])]),l._v(" "),_("li",[_("p",[l._v("关闭TCP连接")]),l._v(" "),_("ul",[_("li",[l._v("通过四次挥手关闭tcp连接\n"),_("ul",[_("li",[l._v("客户端发送一个FIN，用来关闭客户端到服务器的数据传输，客户端进入FIN_WAIT_1状态（浏览器发起，给服务器，我请求发送完了，准备关闭吧）\n"),_("ul",[_("li",[l._v("FIN表示结束标志，用来表示数据传输完成")])])]),l._v(" "),_("li",[l._v("服务器收到FIN后，发送一个ACK给客户端，服务器进入CLOSE_WAIT状态（服务器发起，告诉浏览器我请求报文接受完了，准备关闭吧）")]),l._v(" "),_("li",[l._v("服务器发送一个FIN，用来关闭服务器到客户端的数据传输，服务器进入LAST_ACK状态（服务器告诉浏览器，响应报文发送完了，准备关闭吧）")]),l._v(" "),_("li",[l._v("浏览器接收到FIN，进入TIME_WAIT状态，发送一个ACK给服务器，服务器进入CLOSED状态。（浏览器告诉服务器我响应报文接收完了，我准备关闭了，你也关闭吧）\n"),_("ul",[_("li",[l._v("四次挥手的目的是为了"),_("strong",[l._v("确保双方的数据都能完整地传输结束")])])])])])])])])])])}),[],!1,null,null,null);_.default=u.exports}}]);