(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{465:function(v,a,_){"use strict";_.r(a);var t=_(1),c=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"javascript的执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript的执行机制"}},[v._v("#")]),v._v(" JavaScript的执行机制")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 是一种单线程语言，即在同一时间只能执行一个任务。这意味着 "),a("code",[v._v("JavaScript")]),v._v(" 代码的执行是按照一定的顺序进行的，而不是在多个任务之间进行切换的。"),a("code",[v._v("JavaScript")]),v._v(" 的执行机制可以分为以下几个方面：")]),v._v(" "),a("h2",{attrs:{id:"javascript-的执行环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的执行环境"}},[v._v("#")]),v._v(" JavaScript 的执行环境")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 的执行环境分为主线程和任务队列两部分。主线程负责执行任务，而任务队列则用于存储待执行的任务。当主线程完成一个任务后，它会从任务队列中取出下一个任务并执行，这个过程被称为事件循环。")]),v._v(" "),a("h2",{attrs:{id:"javascript-的事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的事件循环"}},[v._v("#")]),v._v(" JavaScript 的事件循环")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 的事件循环是指 "),a("code",[v._v("JavaScript")]),v._v(" 引擎不断地从任务队列中取出任务并执行的过程。在事件循环中，主线程会不断地从任务队列中取出任务，如果任务队列为空，则等待新的任务进入队列。")]),v._v(" "),a("p",[v._v("任务队列分为两种类型："),a("mark",{staticStyle:{background:"#FF5582A6"}},[v._v("宏任务和微任务")]),v._v("。在事件循环中，主线程会先执行一个宏任务，然后执行所有微任务，再执行下一个宏任务。这个过程会一直持续下去，直到任务队列为空。")]),v._v(" "),a("p",[v._v("具体来说，"),a("code",[v._v("JavaScript")]),v._v(" 中的宏任务包括以下几种：")]),v._v(" "),a("ul",[a("li",[v._v("整体代码块："),a("code",[v._v("JavaScript")]),v._v(" 代码本身就是一个宏任务，即整体代码块。")]),v._v(" "),a("li",[v._v("定时器：使用 "),a("code",[v._v("setTimeout()")]),v._v(" 和 "),a("code",[v._v("setInterval()")]),v._v(" 方法创建的定时器任务。")]),v._v(" "),a("li",[a("code",[v._v("I/O")]),v._v(" 操作：例如 "),a("code",[v._v("Ajax")]),v._v(" 请求、文件读取等异步操作。")]),v._v(" "),a("li",[v._v("事件监听器：例如点击事件、键盘事件等。")])]),v._v(" "),a("p",[v._v("而微任务包括以下几种：")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("Promise.then()")]),v._v(" 方法的回调函数")]),v._v(" "),a("li",[a("code",[v._v("MutationObserver")]),v._v(" 的回调函数")]),v._v(" "),a("li",[a("code",[v._v("process.nextTick()")]),v._v(" 方法的回调函数")])]),v._v(" "),a("p",[v._v("在事件循环中，当下一个宏任务执行完毕后，主线程会立即执行所有微任务，然后再执行下一个宏任务。微任务会优先于下一个宏任务执行，者意味着微任务可以在下一个宏任务之前更新视图或执行一些重要的操作，从而提高代码的性能和用户体验。")]),v._v(" "),a("h2",{attrs:{id:"javascript-的执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的执行顺序"}},[v._v("#")]),v._v(" JavaScript 的执行顺序")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 的执行顺序是由事件循环决定的。当任务进入任务队列时，它被添加到队列的末尾。当主线程空闲时，它会从队列的头部取出一个任务并执行。")]),v._v(" "),a("p",[v._v("具体来说，当一个任务被添加到任务队列中时，它并不会立即执行。相反，它会等待主线程执行完当前的任务，然后再被执行。这意味着任务的执行顺序可能与它们被添加到任务队列中的顺序不同。任务的执行顺序可能因为事件的触发和任务的添加顺序而发生变化。任务的执行是按照事件循环的规则进行的，而不是严格按照任务添加到任务队列的顺序执行。")]),v._v(" "),a("p",[v._v("在事件循环中，当主线程执行一个宏任务时，它可能会创建一些微任务并将它们添加到微任务队列中。当主线程执行完当前的宏任务后，它会立即执行所有微任务，然后再执行下一个宏任务。这个过程会一直重复下去，直到任务队列为空。")]),v._v(" "),a("h2",{attrs:{id:"javascript-的异步执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的异步执行"}},[v._v("#")]),v._v(" JavaScript 的异步执行")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 使用回调函数和 "),a("code",[v._v("Promise")]),v._v(" 对象等方式来实现异步执行。当我们执行一个异步操作时，主线程会继续执行下一个任务，而不会等待异步操作的完成。")]),v._v(" "),a("p",[v._v("当异步操作完成后，"),a("code",[v._v("JavaScript")]),v._v(" 会将回调函数或 "),a("code",[v._v("Promise")]),v._v(" 对象添加到微任务队列中，等待主线程执行。当主线程执行完当前的宏任务后，它会立即执行所有微任务，这样就能在异步操作完成之后立即执行回调函数或 "),a("code",[v._v("Promise")]),v._v(" 对象的处理函数。")]),v._v(" "),a("p",[v._v("需要主要的是，"),a("code",[v._v("JavaScript")]),v._v(" 的异步执行并不是多线程的。在 "),a("code",[v._v("JavaScript")]),v._v(" 中，只有一个主线程，所有的任务都是在同一个线程中执行的。当我们执行耗时的任务时，如果该任务是同步的，则会阻塞主线程，导致页面失去响应；如果该任务是异步的，则主线程会继续执行下一个任务，而不会等待该任务完成。")]),v._v(" "),a("h2",{attrs:{id:"javascript-的执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的执行上下文"}},[v._v("#")]),v._v(" JavaScript 的执行上下文")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 的执行上下文是指 "),a("code",[v._v("JavaScript")]),v._v(" 引擎在执行代码时创建的一个执行环境，它包含了当前正在执行的代码的相关信息，例如变量、函数、作用域等。"),a("code",[v._v("JavaScript")]),v._v(" 中的执行上下文分为以下三种类型：")]),v._v(" "),a("ul",[a("li",[v._v("全局执行上下文："),a("code",[v._v("JavaScript")]),v._v(" 引擎在执行全局代码时创建的执行上下文。它是整个程序的顶层执行上下文，只有一个。")]),v._v(" "),a("li",[v._v("函数执行上下文："),a("code",[v._v("JavaScript")]),v._v(" 引擎在执行函数代码时创建的执行上下文。每次调用函数时都会创建一个新的函数执行上下文。")]),v._v(" "),a("li",[a("code",[v._v("Eval")]),v._v(" 执行上下文："),a("code",[v._v("JavaScript")]),v._v(" 引擎在执行 "),a("code",[v._v("eval()")]),v._v(" 函数时创建的执行上下文。")])]),v._v(" "),a("p",[v._v("每个执行上下文都包含了三个重要 组成部分：")]),v._v(" "),a("ul",[a("li",[v._v("变量对象：用于存储变量、函数和函数参数等信息的对象。")]),v._v(" "),a("li",[v._v("作用域链：用于解析变量和函数的作用域关系的链表。")]),v._v(" "),a("li",[a("code",[v._v("this")]),v._v(" 值：指向当前指向上下文所属的对象。")])]),v._v(" "),a("p",[v._v("在 "),a("code",[v._v("JavaScript")]),v._v(" 中，执行上下文是以栈的形式组织的。当 "),a("code",[v._v("JavaScript")]),v._v(" 引擎开始执行代码时，它会创建全局执行上下文并将其推入执行上下文栈的顶部。当函数执行完成后，"),a("code",[v._v("JavaScript")]),v._v(" 引擎会将该函数执行上下文从栈中弹出，并返回到该函数的执行上下文中。")]),v._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),a("p",[a("code",[v._v("JavaScript")]),v._v(" 的执行机制是由事件循环、执行上下文和异步执行等多个方面共同组成的。了解 "),a("code",[v._v("JavaScript")]),v._v(" 的执行机制对于编写高效的 "),a("code",[v._v("JavaScript")]),v._v(" 代码非常重要。在编写 "),a("code",[v._v("JavaScript")]),v._v(" 代码时，我们应该尽可能的减少对主线程的阻塞，使用异步执行来提高代码的性能和用户体验。同时，我们也应该注意代码的执行顺序和作用域的关系，避免出现不必要的错误。")])])}),[],!1,null,null,null);a.default=c.exports}}]);